---
title: "معماری سیستم‌های عامل گیت‌هاب کوپایلوت، کرسر، و ویندسرف"
tags: [هوش مصنوعی, دستیاران برنامه‌نویسی, گیت‌هاب کوپایلوت, کرسر, ویندسرف, سیستم‌های عامل هوشمند]
keywords: [معماری هوش مصنوعی, گیت‌هاب کوپایلوت, کرسر, ویندسرف, دستیاران برنامه‌نویسی, سیستم‌های عامل هوشمند, تجزیه وظایف, فراخوانی مدل, مدیریت زمینه]
authors: [lark]
description: تحلیل عمیق معماری سیستم‌های عامل هوشمند گیت‌هاب کوپایلوت، کرسر، و ویندسرف، با تمرکز بر فلسفه‌های طراحی آن‌ها، تجزیه وظایف، استراتژی‌های فراخوانی مدل، و مدیریت زمینه برای درک تأثیر آن‌ها بر کمک برنامه‌نویسی مبتنی بر هوش مصنوعی.
image: "https://opengraph-image.blockeden.xyz/api/og-cuckoo-network?title=%D9%85%D8%B9%D9%85%D8%A7%D8%B1%DB%8C%20%D8%B3%DB%8C%D8%B3%D8%AA%D9%85%E2%80%8C%D9%87%D8%A7%DB%8C%20%D8%B9%D8%A7%D9%85%D9%84%20%DA%AF%DB%8C%D8%AA%E2%80%8C%D9%87%D8%A7%D8%A8%20%DA%A9%D9%88%D9%BE%D8%A7%DB%8C%D9%84%D9%88%D8%AA%D8%8C%20%DA%A9%D8%B1%D8%B3%D8%B1%D8%8C%20%D9%88%20%D9%88%DB%8C%D9%86%D8%AF%D8%B3%D8%B1%D9%81"
---

## معماری سیستم‌های عامل هوشمند GitHub Copilot، Cursor، و Windsurf

در سال‌های اخیر، چندین محصول دستیار برنامه‌نویسی هوش مصنوعی، مانند GitHub Copilot، Cursor، و Windsurf ظهور کرده‌اند. پیاده‌سازی‌های آن‌ها همگی مفهوم "عامل هوشمند" (intelligent agent) را معرفی می‌کنند که به هوش مصنوعی اجازه می‌دهد تا به طور فعالانه‌تری در کارهای کدنویسی کمک کند. این مقاله یک بررسی عمیق از ساختار سیستم عامل هوشمند این محصولات را از منظر معماری مهندسی ارائه می‌دهد، از جمله فلسفه طراحی معماری، تجزیه و برنامه‌ریزی وظایف، استراتژی‌های فراخوانی مدل، مدیریت وضعیت زمینه، مکانیزم‌های توسعه افزونه، و مبادلات و نوآوری‌های کلیدی در طراحی‌های مربوطه آن‌ها. محتوای زیر عمدتاً بر اساس وبلاگ‌های رسمی مهندسی، مقالات توسعه‌دهندگان پروژه، و مواد فنی مرتبط است.

![](https://opengraph-image.blockeden.xyz/api/og-cuckoo-network?title=%D9%85%D8%B9%D9%85%D8%A7%D8%B1%DB%8C%20%D8%B3%DB%8C%D8%B3%D8%AA%D9%85%E2%80%8C%D9%87%D8%A7%DB%8C%20%D8%B9%D8%A7%D9%85%D9%84%20%D9%87%D9%88%D8%B4%D9%85%D9%86%D8%AF%20GitHub%20Copilot%D8%8C%20Cursor%D8%8C%20%D9%88%20Windsurf)

### معماری ایجنت گیت‌هاب کوپایلوت

**فلسفه طراحی معماری:** گیت‌هاب کوپایلوت در ابتدا به عنوان "برنامه‌نویس جفت هوش مصنوعی" برای توسعه‌دهندگان معرفی شد و اکنون با حالت "ایجنت" خود، این مفهوم را گسترش داده است. سیستم ایجنت آن مجموعه‌ای از ایجنت‌های مستقل نیست، بلکه یک ایجنت هوشمند تعبیه‌شده است که می‌تواند در مکالمات چند مرحله‌ای و اجرای وظایف چندگامی شرکت کند و از ورودی‌های چندوجهی (مانند استفاده از مدل‌های بینایی برای تفسیر اسکرین‌شات‌ها) پشتیبانی کند. کوپایلوت بر کمک هوش مصنوعی تأکید دارد، نه جایگزینی توسعه‌دهندگان. در حالت ایجنت، بیشتر شبیه یک مهندس خودکار در یک تیم عمل می‌کند، وظایف محول‌شده را می‌پذیرد، به طور خودکار کد می‌نویسد، اشکال‌زدایی می‌کند و نتایج را از طریق درخواست‌های ادغام (Pull Requests) ارسال می‌کند. این ایجنت می‌تواند از طریق رابط چت یا با اختصاص یک گیت‌هاب ایشو (GitHub Issue) به کوپایلوت فعال شود.

**تجزیه و برنامه‌ریزی وظایف:** ایجنت کوپایلوت در تجزیه وظایف پیچیده نرم‌افزاری به زیروظایف و تکمیل آن‌ها یک به یک، با استفاده از یک فرآیند استدلال داخلی مشابه زنجیره تفکر (Chain-of-Thought)، عالی عمل می‌کند. این ایجنت به طور مکرر چرخه "تحلیل مشکل ← اجرای تغییرات کد یا دستورات ← تأیید نتایج" را تکرار می‌کند تا زمانی که الزامات کاربر برآورده شود. به عنوان مثال، در حالت ایجنت، کوپایلوت نه تنها مراحل مشخص‌شده توسط کاربر را اجرا می‌کند، بلکه به طور _ضمنی_ مراحل اضافی مورد نیاز برای دستیابی به هدف اصلی را استنتاج کرده و به طور خودکار اجرا می‌کند. اگر خطاهای کامپایل یا شکست تست‌ها در طول فرآیند رخ دهد، ایجنت خود خطاها را شناسایی و رفع می‌کند و دوباره تلاش می‌کند، بنابراین توسعه‌دهندگان مجبور نیستند پیام‌های خطا را به طور مکرر کپی و به عنوان پرامپت (prompt) جای‌گذاری کنند. یک وبلاگ VS Code چرخه کاری آن را اینگونه خلاصه می‌کند: ایجنت کوپایلوت به طور خودکار زمینه و فایل‌های مرتبط برای ویرایش را تعیین می‌کند، تغییرات کد و دستورات برای اجرا را پیشنهاد می‌دهد، صحت ویرایش‌ها یا خروجی ترمینال را نظارت می‌کند و به طور مداوم تکرار می‌کند تا وظیفه کامل شود. این اجرای خودکار چند مرحله‌ای به کوپایلوت اجازه می‌دهد تا انواع وظایف، از ایجاد یک برنامه ساده تا بازسازی گسترده در چندین فایل را مدیریت کند.

**استراتژی فراخوانی مدل:** مدل‌های پشت گیت‌هاب کوپایلوت در ابتدا Codex از OpenAI بودند که اکنون به یک معماری چندمدلی قدرتمندتر ارتقا یافته‌اند. کوپایلوت به کاربران اجازه می‌دهد تا مدل‌های پایه مختلفی را در "گزینه‌های مدل" انتخاب کنند، مانند GPT-4 از OpenAI (نام کد داخلی gpt-4o) و نسخه ساده‌شده آن، Claude 3.5 از Anthropic (نام کد Sonnet)، و جدیدترین Gemini 2.0 Flash از گوگل، در میان دیگران. این پشتیبانی چندمدلی به این معنی است که کوپایلوت می‌تواند منابع مدل را بر اساس الزامات وظیفه یا ترجیحات کاربر تغییر دهد. در قابلیت Copilot Edits (ویرایش چندفایلی)، گیت‌هاب همچنین از یک معماری دومدلی برای بهبود کارایی استفاده می‌کند: ابتدا، "مدل بزرگ" انتخاب‌شده یک برنامه ویرایش اولیه با زمینه کامل تولید می‌کند، سپس یک نقطه پایانی تخصصی "رمزگشایی گمانه‌زنانه" (speculative decoding) به سرعت این تغییرات را اعمال می‌کند. رمزگشای گمانه‌زنانه را می‌توان به عنوان یک مدل سبک‌وزن یا موتور قوانین در نظر گرفت که نتایج ویرایش را در حالی که مدل بزرگ در حال بررسی تغییرات کد است، از پیش تولید می‌کند، در نتیجه تأخیر را کاهش می‌دهد. به طور خلاصه، استراتژی مدل کوپایلوت این است که چندین مدل زبانی بزرگ (LLM) پیشرفته را در فضای ابری ادغام کند، که برای سناریوهای مختلف بهینه‌سازی شده‌اند، و سرعت پاسخ و دقت را از طریق ابزارهای مهندسی (پایپ‌لاین دومدلی) متعادل کند.

**مدیریت وضعیت و حفظ زمینه:** ایجنت کوپایلوت تأکید زیادی بر استفاده از زمینه توسعه دارد. از آنجایی که ارائه مستقیم کل کد مخزن به عنوان ورودی به مدل‌های بزرگ غیرعملی است، کوپایلوت از یک استراتژی **تولید تقویت‌شده با بازیابی (RAG)** استفاده می‌کند: این ایجنت محتوای مرتبط را در مخزن با استفاده از ابزارهایی مانند GitHub Code Search جستجو می‌کند و قطعه کدهای بازیابی‌شده را به صورت پویا به زمینه مدل تزریق می‌کند. هنگامی که ایجنت شروع به کار می‌کند، کد پروژه را در یک محیط ایزوله کلون می‌کند و ابتدا ساختار پایگاه کد را تحلیل می‌کند و خلاصه‌های لازم را برای صرفه‌جویی در توکن‌ها تولید می‌کند. به عنوان مثال، یک پرامپت که توسط کوپایلوت ساخته می‌شود ممکن است شامل "خلاصه ساختار فایل پروژه + محتوای فایل کلیدی + درخواست کاربر" باشد. این به مدل اجازه می‌دهد تا هنگام تولید راه‌حل‌ها، تصویر کلی را بدون تجاوز از محدودیت‌های طول زمینه درک کند. در طول مکالمات، کوپایلوت همچنین تاریخچه جلسه (مانند دستورالعمل‌هایی که قبلاً توسط کاربر در چت ارائه شده است) را ردیابی می‌کند تا تداوم را حفظ کند. همزمان، کوپایلوت به طور عمیق با پلتفرم گیت‌هاب یکپارچه شده است و به آن اجازه می‌دهد تا از توضیحات ایشوها، بحث‌های مربوط به درخواست‌های ادغام (PR) و غیره به عنوان زمینه اضافی استفاده کند. به طور خاص، اگر مخزن دارای فایل‌های پیکربندی باشد که استانداردهای کدنویسی یا دستورالعمل‌های قبلی برای استفاده از هوش مصنوعی را مشخص می‌کنند، ایجنت نیز به این دستورالعمل‌های سفارشی مخزن پایبند خواهد بود. مهم است که توجه داشته باشیم که کوپایلوت خود حافظه بلندمدت از کد کاربر ندارد – این ایجنت به طور خودکار وضعیت را فراتر از هر جلسه برای جلسه بعدی ذخیره نمی‌کند (مگر اینکه توسط کاربر در مستندات به صورت سخت‌کد شده باشد). با این حال، از طریق ابزارهای ایشو/درخواست ادغام گیت‌هاب، کاربران می‌توانند به طور مؤثر توضیحات وظایف و اسکرین‌شات‌های دائمی را به ایجنت ارائه دهند، که می‌توان آن را به عنوان وسیله‌ای برای حمل زمینه در نظر گرفت.

**سیستم پلاگین و مکانیسم توسعه:** ایجنت گیت‌هاب کوپایلوت عملیات را بر روی IDE و محیط خارجی از طریق فراخوانی ابزارها (Tool Use) انجام می‌دهد. از یک سو، در محیط‌های محلی یا Codespaces، کوپایلوت می‌تواند APIهای ارائه شده توسط افزونه‌های VS Code را برای انجام عملیاتی مانند خواندن فایل‌ها، باز کردن ویرایشگرها، درج قطعه کد و اجرای دستورات ترمینال فراخوانی کند. از سوی دیگر، گیت‌هاب **پروتکل زمینه مدل (Model Context Protocol - MCP)** را برای گسترش "بینایی" و قابلیت‌های ایجنت معرفی کرده است. MCP امکان پیکربندی "سرورهای منابع" خارجی را فراهم می‌کند و ایجنت می‌تواند داده‌ها یا عملیات اضافی را از طریق یک رابط استاندارد درخواست کند. به عنوان مثال، گیت‌هاب به طور رسمی سرور MCP خود را ارائه می‌دهد که به ایجنت اجازه می‌دهد اطلاعات بیشتری در مورد مخزن فعلی (مانند نتایج جستجوی کد، ویکی پروژه و غیره) به دست آورد. مکانیسم MCP از اشخاص ثالث نیز پشتیبانی می‌کند: تا زمانی که آن‌ها رابط MCP را پیاده‌سازی کنند، ایجنت می‌تواند متصل شود، مانند فراخوانی سرویس‌های پرس‌وجوی پایگاه داده یا ارسال درخواست‌های HTTP. ایجنت کوپایلوت در حال حاضر دارای برخی قابلیت‌های چندوجهی است. با یکپارچه‌سازی با مدل‌های بینایی، می‌تواند اسکرین‌شات‌ها، نمودارهای طراحی و سایر تصاویر پیوست‌شده توسط کاربران در ایشوها را به عنوان ورودی کمکی تجزیه کند. این بدان معناست که هنگام اشکال‌زدایی مشکلات UI یا بازتولید خطاها، توسعه‌دهندگان می‌توانند اسکرین‌شات‌ها را به کوپایلوت ارائه دهند، و ایجنت می‌تواند "از روی تصاویر صحبت کند" تا پیشنهادات اصلاح کد مربوطه را ارائه دهد. علاوه بر این، پس از تکمیل یک وظیفه، ایجنت کوپایلوت به طور خودکار تغییرات را از طریق گیت (Git) کامیت می‌کند و یک درخواست ادغام پیش‌نویس (Draft PR) باز می‌کند، سپس توسعه‌دهندگان مرتبط را **منشن (@mentions)** می‌کند تا درخواست بازبینی کند. نظرات و بازخوردهای بازبینان (مانند درخواست اصلاح یک پیاده‌سازی خاص) نیز توسط ایجنت خوانده می‌شوند و به عنوان دستورالعمل‌های جدید عمل می‌کنند و دور بعدی به‌روزرسانی‌های کد را آغاز می‌کنند. کل فرآیند شبیه همکاری توسعه‌دهندگان انسانی است: ایجنت هوش مصنوعی کد را ارسال می‌کند ← انسان بازبینی و بازخورد می‌دهد ← ایجنت هوش مصنوعی اصلاح می‌کند، و اطمینان حاصل می‌شود که انسان‌ها همیشه کنترل را در دست دارند.

**موازنه و نوآوری‌های کلیدی طراحی:** سیستم ایجنت گیت‌هاب کوپایلوت به طور کامل از اکوسیستم پلتفرم گیت‌هاب موجود استفاده می‌کند، که ویژگی مهم آن است. از یک سو، این ایجنت محیط اجرای کد را بر روی کانتینرهای ابری گیت‌هاب اکشنز (GitHub Actions) ایجاد می‌کند و به ایزولاسیون و مقیاس‌پذیری خوبی دست می‌یابد. "پروژه پاداوان" (Project Padawan) نام کد این معماری است که از ساخت یک زیرساخت اجرای جدید از ابتدا جلوگیری می‌کند و به جای آن بر روی یک سیستم CI/CD بالغ بنا می‌شود. از سوی دیگر، کوپایلوت موازنه‌های سخت‌گیرانه‌ای را از نظر امنیت انجام می‌دهد: به طور پیش‌فرض، ایجنت فقط می‌تواند کد را به شاخه‌های تازه ایجاد شده پوش (push) کند، نمی‌تواند مستقیماً شاخه اصلی را تغییر دهد، و درخواست‌های ادغام (PR) فعال‌شده باید قبل از ادغام توسط دیگران تأیید شوند، و پایپ‌لاین‌های CI قبل از تأیید متوقف می‌شوند. این استراتژی‌ها تضمین می‌کنند که معرفی اتوماسیون هوش مصنوعی سیستم بازبینی و دروازه‌های انتشار موجود تیم را مختل نمی‌کند. پیشنهاد پروتکل زمینه مدل (Model Context Protocol) را می‌توان به عنوان یک نوآوری مهندسی مهم برای کوپایلوت در نظر گرفت – این پروتکل یک استاندارد باز برای ایجنت‌های LLM برای دسترسی به ابزارها/داده‌های خارجی تعریف می‌کند، که امکان ادغام بی‌درنگ منابع داده مختلف، هم در داخل و هم در خارج از گیت‌هاب، را در پرامپت‌های هوش مصنوعی در آینده فراهم می‌کند. علاوه بر این، ایجنت کوپایلوت لاگ‌های تفکر (لاگ‌های جلسه) را در طول اجرا ثبت می‌کند، از جمله مراحلی که برای فراخوانی ابزارها و خروجی‌هایی که تولید می‌کند، و این سوابق را به توسعه‌دهنده ارائه می‌دهد. این شفافیت به کاربران اجازه می‌دهد تا "افکار" و اقدامات ایجنت را بازبینی کنند، که اشکال‌زدایی و ایجاد اعتماد را تسهیل می‌کند. به طور کلی، گیت‌هاب کوپایلوت ایجنت‌های هوش مصنوعی را در مراحل مختلف چرخه عمر توسعه (کدنویسی -> ارسال درخواست ادغام (PR) -> بازبینی کد) تعبیه می‌کند، و از طریق مجموعه‌ای از تصمیمات معماری، ادغام بی‌درنگ اتوماسیون با گردش کار موجود را محقق می‌سازد.

### معماری عامل Cursor

**فلسفه طراحی معماری:** Cursor یک ابزار کدنویسی مبتنی بر هوش مصنوعی است که توسط استارتاپ Anysphere توسعه یافته است. این ابزار اساساً یک ویرایشگر کد (بر اساس VS Code اصلاح شده) است که به طور عمیق با یک دستیار هوش مصنوعی یکپارچه شده است. Cursor دو حالت تعامل اصلی ارائه می‌دهد: دستیار چت و عامل مستقل. در حالت مکالمه عادی، به عنوان یک دستیار کد سنتی عمل می‌کند، به سؤالات پاسخ می‌دهد یا کد را بر اساس دستورالعمل‌ها تولید می‌کند؛ هنگامی که به حالت عامل (که با نام "Composer" نیز شناخته می‌شود) تغییر می‌کند، Cursor می‌تواند به طور فعال مجموعه‌ای از عملیات را از طرف توسعه‌دهنده اجرا کند. این معماری به کاربران آزادی انتخاب می‌دهد: وظایف ساده را می‌توان با پرسیدن خط به خط در حالت دستیار انجام داد، در حالی که وظایف پیچیده یا تکراری را می‌توان با فراخوانی عامل به صورت دسته‌ای پردازش کرد. Cursor در حال حاضر عمدتاً بر کمک در حوزه متن (کد) تمرکز دارد و بر ورودی/خروجی چندوجهی تأکید نمی‌کند (اگرچه قابلیت ورودی صوتی را فراهم می‌کند که گفتار را برای پرامپت‌ها به متن تبدیل می‌کند). مشابه Copilot، سیستم عامل Cursor نیز به عنوان یک عامل هوشمند واحد به صورت سریالی عمل می‌کند، نه چندین عامل که به صورت موازی کار می‌کنند. با این حال، ویژگی متمایز آن تأکید بر همکاری انسان و هوش مصنوعی است: در حالت عامل، هوش مصنوعی تا حد امکان اقدامات زیادی را انجام می‌دهد، اما در مجموع همچنان به توسعه‌دهندگان اجازه می‌دهد در هر زمان مداخله کرده و کنترل را به دست بگیرند، به جای اینکه برای مدت طولانی کاملاً بدون نظارت اجرا شود.

**تجزیه و تحلیل و برنامه‌ریزی وظیفه:** در حالت عامل Cursor، هوش مصنوعی می‌تواند وظایف پیچیده بین‌فایلی را مدیریت کند، اما طراحی به سمت سبک درخواست گام به گام متمایل است. پس از دریافت یک دستورالعمل سطح بالا از کاربر، عامل به طور مستقل قطعه کدهای مرتبط را جستجو می‌کند، فایل‌هایی را که نیاز به ویرایش دارند باز می‌کند، برنامه‌های اصلاح را تولید می‌کند و حتی دستورات تست/ساخت را برای تأیید اثر اجرا می‌کند. با این حال، برخلاف عوامل Copilot یا Windsurf، عامل Cursor معمولاً پس از تکمیل یک پیشنهاد اولیه متوقف می‌شود و منتظر بررسی کاربر و دستورالعمل‌های بیشتر می‌ماند. این بدان معناست که عامل Cursor عموماً به طور مداوم و مکرر خود را بهبود نمی‌بخشد مگر اینکه یک پرامپت جدید از کاربر دریافت کند. به عنوان مثال، اگر از Cursor بخواهید یک بازسازی بین‌پروژه‌ای را انجام دهد، تمام مکان‌هایی را که نیاز به اصلاح دارند جمع‌آوری کرده و یک diff برای هر فایل برای بررسی کاربر تولید می‌کند؛ در این مرحله، کاربر تصمیم می‌گیرد کدام تغییرات را بپذیرد و اعمال کند. اگر این تغییرات مشکلات جدیدی ایجاد کنند، Cursor به طور خودسرانه به اصلاح ادامه نمی‌دهد مگر اینکه کاربر درخواست‌های بیشتری مانند "مشکلات ظاهر شده را برطرف کن" را مطرح کند. این مکانیسم نظارت انسانی را در نقاط تصمیم‌گیری حیاتی تضمین می‌کند و از سرکش شدن هوش مصنوعی جلوگیری می‌کند. با این حال، این بدان معناست که عامل Cursor فاقد استقلال برای برنامه‌ریزی زنجیره طولانی است و برای تکمیل حلقه‌های بسته پیچیده به راهنمایی گام به گام انسانی نیاز دارد. برای بهبود جزئی استقلال مداوم، تیم Cursor برخی ویژگی‌های تکراری را نیز به سیستم عامل اضافه کرده است. به عنوان مثال، سعی می‌کند کد را کامپایل و اجرا کند و خطاها را بگیرد، برخی مشکلات ساده مانند خطاهای نحوی یا lint را به طور خودکار برطرف می‌کند، اما معمولاً پس از چند تلاش متوقف می‌شود و کنترل را به کاربر بازمی‌گرداند. توسعه‌دهندگان مشاهده کرده‌اند که عامل Cursor در بازسازی محلی یا تغییرات با دامنه محدود بسیار کارآمد عمل می‌کند، اما برای تغییرات گسترده، اغلب نیاز دارد که کاربر به صورت بخش‌بندی شده پرامپت دهد و وظیفه را گام به گام تکمیل کند. در مجموع، Cursor عامل را به عنوان یک "دستیار اجرای هوشمند" قرار می‌دهد تا یک ربات برنامه‌نویسی خودکار همه‌کاره؛ برنامه‌ریزی وظیفه آن به سمت اجرای کوتاه‌مدت، گزارش‌دهی به موقع و اجازه دادن به انسان برای تصمیم‌گیری در مورد گام بعدی متمایل است.

**استراتژی فراخوانی مدل:** Cursor مدل‌های زبان بزرگ خود را آموزش نمی‌دهد؛ بلکه استراتژی یکپارچه‌سازی APIهای شخص ثالث را اتخاذ می‌کند. کاربران می‌توانند کلیدهای API را از فروشندگانی مانند OpenAI یا Anthropic در Cursor پیکربندی کنند، و سپس بک‌اند Cursor مدل بزرگ مربوطه را از طرف کاربر فراخوانی می‌کند. صرف نظر از اینکه کاربر کدام ارائه‌دهنده مدل را انتخاب می‌کند، تمام درخواست‌های هوش مصنوعی از سرور خود Cursor عبور خواهند کرد: برنامه محلی، زمینه ویرایشگر و سؤالات کاربر را بسته‌بندی کرده و به ابر ارسال می‌کند، سرور Cursor پرامپت کامل را مونتاژ کرده و مدل را فراخوانی می‌کند، و سپس نتایج را به ویرایشگر بازمی‌گرداند. این معماری بهینه‌سازی پرامپت‌ها و مدیریت یکپارچه وضعیت‌های جلسه را برای Cursor تسهیل می‌کند، اما همچنین به این معنی است که باید به صورت آنلاین استفاده شود و عملکردهای اصلی هوش مصنوعی در حالت آفلاین در دسترس نیستند. برای ملاحظات هزینه توسعه‌دهنده، Cursor از کاربران پشتیبانی می‌کند تا از سهمیه API خود استفاده کنند (بنابراین صورت‌حساب فراخوانی مدل به کاربر می‌رسد)، اما حتی در این صورت، درخواست‌ها همچنان برای عملیاتی مانند بازیابی کد امبدینگ و قالب‌بندی پاسخ از سرور رسمی عبور می‌کنند. از نظر انتخاب مدل، Cursor عموماً چند مدل اصلی را برای انتخاب ارائه می‌دهد (مانند GPT-4، GPT-3.5، Claude 2 و غیره)؛ کاربران می‌توانند یکی را ترجیح دهند، اما نمی‌توانند به مدل‌هایی که توسط Cursor پشتیبانی نمی‌شوند دسترسی پیدا کنند. در مقابل، سیستم‌هایی مانند Windsurf اجازه می‌دهند موتور زیرین جایگزین شود، در حالی که Cursor بسته‌تر است و به‌روزرسانی‌ها و تنظیمات مدل عمدتاً توسط تیم رسمی کنترل می‌شود. علاوه بر این، Cursor راه‌حل‌های استقرار محلی مانند Copilot Enterprise ندارد و مدل‌های متن‌باز را نیز یکپارچه نمی‌کند – کاملاً سرویس ابری محور است، بنابراین می‌تواند به سرعت با آخرین نسخه‌های مدل بزرگ همگام شود، اما همچنین نیاز دارد که کاربران به پردازش ابری آن اعتماد کرده و از سیاست‌های حریم خصوصی مربوطه پیروی کنند. لازم به ذکر است که Cursor یک "حالت تفکر" (Thinking mode) ارائه می‌دهد؛ طبق بازخورد کاربران، فعال کردن آن پاسخ‌های هوش مصنوعی را عمیق‌تر و دقیق‌تر می‌کند، که احتمالاً به معنای تغییر به یک مدل قدرتمندتر یا تنظیمات پرامپت خاص است، اما جزئیات پیاده‌سازی خاص توسط تیم رسمی توضیح داده نشده است.

**مدیریت وضعیت و حفظ زمینه:** برای افزایش درک خود از کل پروژه، Cursor کدبیس را به صورت محلی یا در ابر پیش‌پردازش می‌کند: بردارهای امبدینگ را برای تمام فایل‌ها محاسبه کرده و یک فهرست معنایی برای پشتیبانی از جستجوی معنایی و تطابق مرتبطی می‌سازد. به طور پیش‌فرض، هنگامی که یک پروژه جدید باز می‌شود، Cursor به طور خودکار قطعه کدهای موجود را به صورت دسته‌ای به سرور ابری آپلود می‌کند تا امبدینگ‌ها را تولید کرده و ذخیره کند (فقط بردارهای امبدینگ و هش فایل‌ها را ذخیره می‌کند، نه کد متن ساده). به این ترتیب، هنگامی که کاربران سؤالاتی در مورد کد می‌پرسند، Cursor می‌تواند فایل‌ها یا قطعه کدهای مرتبط را در فضای امبدینگ جستجو کرده و محتوای آن‌ها را استخراج کند تا برای مرجع به مدل ارائه دهد، بدون اینکه مجبور باشد کل کدبیس را به پرامپت وارد کند. با این حال، به دلیل پنجره زمینه محدود مدل (هزاران تا ده‌ها هزار توکن)، استراتژی Cursor تمرکز بر زمینه فعلی است: یعنی عمدتاً اجازه می‌دهد مدل بر فایل در حال ویرایش توسط کاربر، بخش کد انتخاب شده، یا قطعه کدهایی که کاربر فعالانه ارائه کرده است، تمرکز کند. Cursor یک نقطه ورودی "کدبیس شما را می‌شناسد" (Knows your codebase) دارد که به شما امکان می‌دهد در مورد محتوای فایل‌های باز نشده سؤال کنید؛ این اساساً یک جستجوی معنایی را در پس‌زمینه انجام می‌دهد و محتوای مرتبط یافت شده را در پرامپت وارد می‌کند. به عبارت دیگر، اگر می‌خواهید هوش مصنوعی یک قطعه کد خاص را در نظر بگیرد، معمولاً باید آن فایل را باز کنید یا آن را در مکالمه جای‌گذاری کنید؛ در غیر این صورت، Cursor به طور پیش‌فرض محتوای فایل "نامربوط" زیادی را به مدل نمی‌دهد. این مدیریت زمینه تضمین می‌کند که پاسخ‌ها دقیقاً متمرکز هستند، اما ممکن است ارتباطات ضمنی بین‌فایلی در پروژه را از دست بدهد، مگر اینکه کاربر متوجه شود و هوش مصنوعی را برای بازیابی آن‌ها پرامپت کند. برای حل مشکل حافظه بلندمدت، Cursor مکانیسم قوانین پروژه (Project Rules) را فراهم می‌کند. توسعه‌دهندگان می‌توانند فایل‌های `.cursor/rules/*.mdc` را برای ثبت دانش مهم پروژه، استانداردهای کدنویسی یا حتی دستورالعمل‌های خاص ایجاد کنند، و Cursor به طور خودکار این قوانین را به عنوان بخشی از پرامپت سیستمی در هر بار شروع جلسه بارگذاری می‌کند. به عنوان مثال، می‌توانید یک قانون مانند "تمام توابع API باید لاگ شوند" را ایجاد کنید، و Cursor هنگام تولید کد از این قرارداد پیروی خواهد کرد – برخی کاربران گزارش داده‌اند که با انباشت مداوم تجربه پروژه در فایل‌های قوانین، درک Cursor و سازگاری آن با پروژه به طور قابل توجهی بهبود می‌یابد. این فایل‌های قوانین معادل حافظه بلندمدتی هستند که توسط توسعه‌دهنده به عامل داده می‌شود و توسط انسان نگهداری و به‌روزرسانی می‌شوند (همچنین می‌توان از Cursor خواست که "نتایج این مکالمه را به قوانین اضافه کند"). علاوه بر این، Cursor از ادامه زمینه تاریخچه مکالمه پشتیبانی می‌کند: در یک جلسه، سؤالات قبلی پرسیده شده توسط کاربر و پاسخ‌های ارائه شده توسط Cursor به عنوان بخشی از زنجیره مکالمه به مدل منتقل می‌شوند و از سازگاری در ارتباطات چندنوبتی اطمینان حاصل می‌کنند. با این حال، Cursor در حال حاضر به طور خودکار مکالمات قبلی را در جلسات مختلف به خاطر نمی‌سپارد (مگر اینکه در فایل‌های قوانین ذکر شده ذخیره شوند)؛ هر جلسه جدید با قوانین پروژه + زمینه فعلی از نو شروع می‌شود.

**سیستم پلاگین و مکانیسم توسعه:** عامل Cursor می‌تواند عملیات مشابه Copilot را فراخوانی کند، اما از آنجا که Cursor خود یک IDE کامل است، یکپارچگی ابزار آن بیشتر داخلی است. به عنوان مثال، Cursor ابزارهایی مانند `open_file`، `read_file`، `edit_code`، `run_terminal` و غیره را تعریف می‌کند و هدف و نحوه استفاده از آن‌ها را به تفصیل در پرامپت سیستمی توضیح می‌دهد. این توضیحات بارها توسط تیم تنظیم شده‌اند تا اطمینان حاصل شود که LLM می‌داند چه زمانی از ابزار مناسب در زمینه مناسب استفاده کند. وبلاگ رسمی Anthropic زمانی اشاره کرد که طراحی پرامپت‌های مؤثر برای آموزش نحوه استفاده از ابزارها به یک مدل، خود یک هنر است، و Cursor به وضوح تلاش زیادی در این زمینه کرده است. به عنوان مثال، Cursor به صراحت در پرامپت سیستمی بیان می‌کند: "قطعه کدهای کامل را مستقیماً به کاربر خروجی ندهید؛ در عوض، تغییرات را از طریق `edit_tool` ارسال کنید" تا از دور زدن ابزار توسط هوش مصنوعی و چاپ مستقیم بلوک‌های بزرگ متن جلوگیری کند. مثال دیگر این است: "قبل از فراخوانی هر ابزار، در یک جمله به کاربر توضیح دهید که چرا این کار را انجام می‌دهید،" تا زمانی که هوش مصنوعی برای مدت طولانی عملیاتی را به صورت "بی‌صدا" انجام می‌دهد، کاربر به اشتباه فکر نکند که متوقف شده است. این طراحی‌های دقیق تجربه کاربری و اعتماد را افزایش می‌دهند. علاوه بر ابزارهای داخلی، Cursor از نصب "پلاگین‌های" اضافی از طریق پروتکل زمینه مدل (MCP) نیز پشتیبانی می‌کند. از دیدگاه مهندسی، Cursor پروتکل MCP را به عنوان یک رابط استاندارد برای گسترش قابلیت‌های عامل می‌بیند: توسعه‌دهندگان می‌توانند یک سرویس را مطابق با مشخصات MCP برای فراخوانی توسط Cursor بنویسند، و بدین ترتیب به عملکردهای مختلفی مانند دسترسی به پایگاه‌های داده، فراخوانی APIهای خارجی، یا حتی کنترل مرورگرها دست یابند. به عنوان مثال، برخی از کاربران جامعه، یکپارچه‌سازی پایگاه داده برداری OpenAI را از طریق MCP برای ذخیره و بازیابی دانش پروژه بلندمدت‌تر به اشتراک گذاشته‌اند که به طور مؤثری "حافظه بلندمدت" را به عامل Cursor اضافه می‌کند. مهم است که توجه داشته باشید که سرویس‌های MCP معمولاً به صورت محلی یا در یک ابر خصوصی راه‌اندازی می‌شوند. Cursor آدرس‌ها و دستورالعمل‌های موجود این سرویس‌ها را از طریق فایل‌های پیکربندی می‌شناسد، و سپس مدل می‌تواند آن‌ها را بر اساس لیست ابزارهای ارائه شده در پرامپت سیستمی فراخوانی کند. به طور خلاصه، مکانیسم پلاگین Cursor به عامل آن درجه‌ای از برنامه‌ریزی‌پذیری می‌دهد و به کاربران امکان می‌دهد قابلیت‌های هوش مصنوعی را گسترش دهند.

**موازنه و نوآوری‌های کلیدی طراحی:** Cursor به عنوان یک محصول IDE، در طراحی سیستم عامل خود در مقایسه با GitHub Copilot، موازنه‌های متفاوتی را انجام داده است. اول، یک معماری اجرای مبتنی بر ابر را انتخاب کرده است، به این معنی که کاربران برای استفاده از مدل‌های قدرتمند هوش مصنوعی نیازی به آماده‌سازی قدرت محاسباتی محلی ندارند، و Cursor می‌تواند به طور یکپارچه عملکردهای بک‌اند را ارتقا و بهینه کند. هزینه آن این است که کاربران باید به خدمات ابری آن اعتماد کنند و تأخیر شبکه را بپذیرند، اما Cursor از طریق "حالت حریم خصوصی" (وعده عدم ذخیره طولانی‌مدت کد کاربر و تاریخچه چت) تضمین‌هایی را ارائه می‌دهد. دوم، از نظر تعامل با مدل‌ها، Cursor بر اهمیت مهندسی پرامپت تأکید می‌کند. همانطور که توسعه‌دهندگان توضیح داده‌اند، پرامپت سیستمی Cursor با دقت قوانین متعددی را تنظیم می‌کند، از عدم عذرخواهی در کلمات گرفته تا اجتناب از ارجاعات توهمی به ابزارهای غیرموجود – جزئیات مختلفی در نظر گرفته شده است. این دستورالعمل‌های پنهان به شدت بر کیفیت و ثبات رفتاری پاسخ‌های هوش مصنوعی تأثیر می‌گذارند. این "تنظیم عمیق" خود یک نوآوری مهندسی است: تیم Cursor مجموعه‌ای از الگوهای پرامپت را از طریق آزمایش مداوم پیدا کرده است که LLMهای عمومی را به "متخصصان کدنویسی" تبدیل می‌کند و به طور مداوم آن‌ها را با تکامل نسخه‌های مدل تنظیم می‌کند. سوم، Cursor یک استراتژی محافظه‌کارانه در تقسیم کار انسان و ماشین اتخاذ می‌کند – ترجیح می‌دهد هوش مصنوعی کمی کمتر کار کند تا اطمینان حاصل شود که کاربر همیشه آگاه است. به عنوان مثال، هر تغییر عمده از یک لیست diff برای تأیید کاربر استفاده می‌کند، برخلاف برخی از عوامل که مستقیماً کد را اصلاح می‌کنند و سپس به شما می‌گویند "انجام شد". این تصمیم محصولی، نقص فعلی هوش مصنوعی و نیاز به نظارت انسانی را به رسمیت می‌شناسد. اگرچه برخی از کارایی اتوماسیون را قربانی می‌کند، اما قابلیت اطمینان بالاتر و پذیرش کاربر را به دست می‌آورد. در نهایت، رویکرد توسعه‌پذیری Cursor قابل توجه است: استفاده از قوانین پروژه برای اجازه دادن به کاربران برای جبران کمبودهای زمینه و حافظه، و استفاده از پلاگین‌های MCP برای اجازه دادن به کاربران پیشرفته برای گسترش قابلیت‌های هوش مصنوعی. این طراحی‌ها فضای سفارشی‌سازی عمیقی را برای کاربران فراهم می‌کنند و اساس انطباق پذیری انعطاف‌پذیر آن با تیم‌ها و وظایف مختلف هستند. در زمینه رقابتی شدید دستیار هوش مصنوعی، Cursor به دنبال حداکثر اتوماسیون سرتاسری نیست، بلکه یک پلتفرم دستیار هوش مصنوعی بسیار انعطاف‌پذیر می‌سازد که می‌تواند توسط توسعه‌دهندگان آموزش داده شود، که یک ویژگی اصلی فلسفه مهندسی آن است.

### معماری عامل ویندسرف (کودیوم)

**فلسفه طراحی معماری:** ویندسرف (Windsurf) یک محصول برنامه‌نویسی مبتنی بر هوش مصنوعی است که توسط تیم کودیوم (Codeium) عرضه شده و به عنوان اولین "IDE عامل‌محور" (محیط توسعه یکپارچه هوشمند مبتنی بر عامل) در صنعت شناخته می‌شود. برخلاف کوپایلوت (Copilot) که نیاز به جابجایی بین حالت‌های چت/عامل دارد، دستیار هوش مصنوعی ویندسرف (با نام کاسکید - Cascade) همواره دارای قابلیت‌های عامل است و به صورت یکپارچه بین پاسخگویی به سوالات و اجرای مستقل وظایف چند مرحله‌ای در صورت نیاز جابجا می‌شود. کودیوم به طور رسمی فلسفه خود را به صورت "فلوها (Flows) = عامل‌ها (Agents) + کوپایلوت‌ها (Copilots)" خلاصه می‌کند. یک فلو به معنای قرار گرفتن توسعه‌دهندگان و هوش مصنوعی در یک وضعیت همکاری همزمان است: هوش مصنوعی در هر زمان مانند یک دستیار پیشنهاداتی ارائه می‌دهد و همچنین می‌تواند در صورت نیاز به صورت فعالانه کنترل را به دست گرفته و مجموعه‌ای از عملیات را اجرا کند، در حالی که کل فرآیند در همگام‌سازی لحظه‌ای با عملیات توسعه‌دهنده باقی می‌ماند. این معماری نقاط جابجایی نقش انسان و ماشین مشخصی ندارد؛ هوش مصنوعی به طور مداوم "اقدامات" توسعه‌دهنده را "استراق سمع" کرده و خود را با ریتم او تطبیق می‌دهد. هنگامی که با کاسکید در ویندسرف چت می‌کنید، می‌تواند مستقیماً به سوالات شما پاسخ دهد یا گفته شما را به عنوان یک وظیفه تفسیر کند، سپس مجموعه‌ای از عملیات را آغاز کند. به عنوان مثال، اگر کاربر به سادگی در یک مکالمه به کاسکید بگوید: "لطفاً احراز هویت کاربر را پیاده‌سازی کرده و بخش‌های کد مربوطه را به‌روزرسانی کنید"، کاسکید می‌تواند به طور خودکار این را به عنوان یک نیاز بین‌ماژولی درک کند: پایگاه کد را برای یافتن فایل‌های مرتبط با احراز هویت کاربر جستجو می‌کند، این فایل‌ها را باز و ویرایش می‌کند (مثلاً افزودن توابع احراز هویت، ایجاد پیکربندی‌های جدید، تغییر منطق فراخوانی)، در صورت لزوم تست‌های پروژه را اجرا می‌کند و در نهایت وضعیت تکمیل را به کاربر گزارش می‌دهد. در طول این فرآیند، توسعه‌دهنده نیازی به جابجایی حالت یا ارائه دستورالعمل گام به گام ندارد. از نظر چندوجهی بودن، ویندسرف/کاسکید فعلی عمدتاً بر حوزه متن کد تمرکز دارد و هنوز به پشتیبانی از تجزیه تصویر یا صدا اشاره‌ای نکرده است. با این حال، درک کاسکید از "قصد توسعه‌دهنده" نه تنها از ورودی متنی خالص، بلکه از سیگنال‌های مختلف در محیط IDE نیز نشأت می‌گیرد (به بخش زمینه در ادامه مراجعه کنید). به طور کلی، فلسفه معماری ویندسرف این است که هوش مصنوعی را در IDE ادغام کند: از یک ابزار پاسخگویی منفعل به یک شریک همکاری فعال تکامل یابد تا کارایی توسعه را به حداکثر برساند.

**تجزیه وظایف و خودمختاری:** کاسکید یکی از قوی‌ترین قابلیت‌های ارکستراسیون مستقل را در میان محصولات فعلی داراست. برای دستورالعمل‌های سطح بالا که توسط کاربر داده می‌شود، ابتدا تجزیه و تحلیل جامع قصد و ارزیابی دامنه را انجام می‌دهد، سپس به طور خودکار مجموعه‌ای از اقدامات خاص را برای دستیابی به هدف آغاز می‌کند. در مثال افزودن قابلیت احراز هویت جدید، کاسکید ممکن است مراحل داخلی زیر را انجام دهد: ۱) پروژه را اسکن کند تا ماژول‌هایی را که نیاز به تغییر یا ایجاد دارند (مانند مدل کاربر، سرویس احراز هویت، پیکربندی، کامپوننت‌های رابط کاربری و غیره) پیدا کند؛ ۲) تغییرات کد مربوطه را تولید کند، از جمله افزودن توابع، تنظیم فراخوانی‌ها و به‌روزرسانی پیکربندی‌ها؛ ۳) از ابزارهای ارائه شده توسط ویندسرف برای باز کردن فایل‌ها و درج تغییرات استفاده کند؛ ۴) مجموعه‌های تست موجود را اجرا کند یا یک سرور توسعه را راه‌اندازی کند تا بررسی کند که آیا تغییرات جدید به درستی کار می‌کنند یا خیر. اگر تست‌ها مشکلاتی را نشان دهند، کاسکید متوقف نمی‌شود و منتظر دخالت انسان نمی‌ماند، بلکه به تجزیه و تحلیل خطا، یافتن باگ، اصلاح خودکار کد و اجرای مجدد تست‌ها برای تأیید ادامه می‌دهد. این حلقه بسته می‌تواند برای چندین دور ادامه یابد تا زمانی که کاسکید مطمئن شود وظیفه کامل شده است یا با مانعی غیرقابل حل مواجه شود. قابل ذکر است که ویندسرف بر حفظ مشارکت توسعه‌دهنده تأکید دارد، اما بدون اینکه بار زیادی بر دوش او بگذارد. به طور خاص، کاسکید پس از اجرای تغییرات کلیدی، تفاوت‌ها (diffs) را برای تمام فایل‌های تغییر یافته به کاربر نمایش می‌دهد و یک تأیید دسته‌ای یکباره را درخواست می‌کند. کاربران می‌توانند هر تفاوت را مرور کرده و تصمیم بگیرند که تغییرات را بپذیرند یا بازگردانند. این مرحله به طور مؤثر یک مرحله بازبینی انسانی را بین بازسازی خودکار هوش مصنوعی و ارسال کد اضافه می‌کند، نه عملیات مداوم هوش مصنوعی را بیش از حد مختل می‌کند و نه اطمینان می‌دهد که نتیجه نهایی انتظارات انسان را برآورده می‌کند. در مقایسه با کرسر (Cursor) که از کاربر می‌خواهد هر مرحله را هدایت کند، کاسکید ویندسرف به سمت خودمختاری پیش‌فرض گرایش دارد: کاربر به سادگی نیاز را بیان می‌کند و هوش مصنوعی تمام زیروظایف را تا حد امکان تکمیل می‌کند، سپس نتایج را برای پذیرش به کاربر تحویل می‌دهد. این حالت کاری به طور کامل از مزیت هوش مصنوعی در مدیریت عملیات پیچیده استفاده می‌کند، در حالی که ریسک را از طریق طراحی "تأیید نهایی" مدیریت می‌کند.

**استراتژی فراخوانی مدل:** فناوری هوش مصنوعی پشت ویندسرف عمدتاً از مدل‌ها و زیرساخت‌های خود توسعه یافته کودیوم نشأت می‌گیرد. کودیوم در زمینه دستیارهای کدنویسی هوش مصنوعی تجربه اندوخته است (پلاگین کودیوم ویژگی‌های تکمیل مشابه کوپایلوت را ارائه می‌دهد)، و گمان می‌رود که مدل مورد استفاده توسط کاسکید، مدل زبان بزرگ کودیوم است که برای برنامه‌نویسی بهینه شده است (احتمالاً بر اساس مدل‌های متن‌باز تنظیم شده یا چندین مدل را ادغام می‌کند). یک تفاوت آشکار این است که کودیوم گزینه‌های میزبانی شخصی (self-hosting) را برای کاربران سازمانی ارائه می‌دهد، به این معنی که مدل‌ها و سرویس‌های استنتاجی مورد استفاده توسط ویندسرف می‌توانند بر روی سرورهای خود شرکت مستقر شوند. این بدان معناست که از نظر معماری، کودیوم به APIهای شخص ثالث مانند OpenAI متکی نیست؛ مدل‌های اصلی آن می‌توانند توسط کودیوم ارائه شده و در محیط مشتری اجرا شوند. در واقع، پلتفرم کودیوم از مفهوم "موتورها" (Engines) پشتیبانی می‌کند، جایی که کاربران می‌توانند موتور بک‌اند هوش مصنوعی را انتخاب کنند، به عنوان مثال، استفاده از مدل خود کودیوم "Sonnet" (یکی از نام‌های کد داخلی مدل کودیوم) یا یک جایگزین مدل متن‌باز. این طراحی از نظر تئوری به ویندسرف انعطاف‌پذیری مدل می‌دهد: در صورت نیاز، می‌تواند به یک موتور مدل معادل دیگر تغییر کند، برخلاف کرسر که تنها می‌تواند از چند مدل ثابت فهرست شده توسط تیم رسمی استفاده کند. تحت پیکربندی پیش‌فرض فعلی، بیشتر هوشمندی ویندسرف از سرویس‌های آنلاین کودیوم می‌آید و استنتاج آن نیز در فضای ابری انجام می‌شود. با این حال، برخلاف کرسر که کاملاً به سرویس‌های راه دور متکی است، ویندسرف برخی از عملکردهای هوش مصنوعی را به صورت محلی بهینه کرده است: به عنوان مثال، ویژگی تکمیل تب (Supercomplete)، طبق اطلاعات رسمی، توسط مدل کوچک خود توسعه یافته کودیوم هدایت می‌شود که با سرعت بالا بر روی سرورهای محلی/نزدیک اجرا می‌شود. این باعث می‌شود پیشنهادات فوری در طول کدنویسی روزانه از نظر تأخیر تقریباً غیرقابل درک باشند، در حالی که مدل‌های ابری قدرتمند برای مکالمات پیچیده یا تولید در مقیاس بزرگ فراخوانی می‌شوند. برای مشتریان سازمانی که به امنیت داده‌ها اهمیت می‌دهند، بزرگترین مزیت ویندسرف پشتیبانی آن از استقرار "ایزوله" (air-gapped) است: شرکت‌ها می‌توانند موتور کامل هوش مصنوعی کودیوم را در داخل فایروال خود نصب کنند و تمام کد و داده‌های پرامپت در شبکه داخلی باقی می‌مانند. بنابراین، ویندسرف در استراتژی مدل خود انتخاب متفاوتی نسبت به کرسر انجام داده است – تلاش برای خودمختاری بیشتر مدل و انعطاف‌پذیری استقرار، به جای اتکای کامل به APIهای شرکت‌های پیشرو هوش مصنوعی. این انتخاب نیاز به سرمایه‌گذاری مهندسی بیشتری دارد (آموزش و نگهداری مدل‌های اختصاصی، و همچنین پشتیبانی استقرار پیچیده)، اما در بازار سازمانی به رسمیت شناخته شده است. این نیز یکی از اولویت‌های طراحی مهندسی کودیوم است.

**مدیریت وضعیت و حفظ زمینه:** از آنجایی که کاربران هدف شامل تیم‌هایی هستند که مخازن کد بزرگ را مدیریت می‌کنند، ویندسرف سرمایه‌گذاری زیادی در طراحی مهندسی برای مدیریت زمینه (context) انجام داده است. هسته آن مجموعه‌ای از مکانیزم‌های فهرست‌بندی و بازیابی کد است: هنگامی که کاربر یک مخزن را باز می‌کند، ویندسرف به طور خودکار تمام کد را اسکن کرده و یک فهرست معنایی را به صورت محلی (با استفاده از امبدینگ‌های برداری - vector embeddings) ایجاد می‌کند. این فرآیند شبیه به ساخت یک جستجوی تمام متن پروژه است، اما هوشمندتر – این فهرست به هوش مصنوعی اجازه می‌دهد تا محتوای مرتبط را از هر فایلی در صورت نیاز بدون بارگذاری صریح آن فایل بازیابی کند. بنابراین، هنگامی که کاسکید نیاز به پاسخگویی به سوالاتی دارد که شامل چندین فایل می‌شوند، می‌تواند به سرعت قطعات مرتبط را از فهرست پیدا کرده و محتوای آنها را به زمینه مدل اضافه کند. به عنوان مثال، اگر بپرسید "تابع X کجا تعریف شده است؟"، کاسکید می‌تواند بلافاصله تعریف را از طریق فهرست پیدا کرده و پاسخی ارائه دهد، حتی اگر هرگز آن فایل را باز نکرده باشد. این "آگاهی از زمینه جهانی" (global context awareness) توانایی هوش مصنوعی را در درک پروژه‌های بزرگ به شدت افزایش می‌دهد زیرا محدودیت‌های فیزیکی پنجره زمینه را می‌شکند و اساساً به هوش مصنوعی یک پایگاه داده پرس و جوی فوری در مورد پروژه می‌دهد. علاوه بر این، ویندسرف تأکید زیادی بر حافظه بلندمدت دارد و ویژگی "حافظه‌ها" (Memories) را معرفی کرده است. حافظه‌ها به دو دسته تقسیم می‌شوند: یکی "یادداشت‌ها" یا "قوانین" تعریف شده توسط کاربر است، جایی که توسعه‌دهندگان می‌توانند به صورت فعالانه اطلاعات دائمی (مانند توضیحات معماری پروژه، راهنماهای سبک کدنویسی و غیره) را به کاسکید ارائه دهند که به طور مداوم ذخیره شده و در صورت لزوم برای ارجاع به مدل ارائه می‌شوند. دسته دیگر حافظه‌هایی هستند که به طور خودکار ضبط می‌شوند، مانند خلاصه‌ای از مکالمات گذشته بین هوش مصنوعی و کاربر، تصمیمات مهمی که هوش مصنوعی در پروژه گرفته است و غیره که نیز ذخیره می‌شوند. هنگامی که چند روز بعد دوباره ویندسرف را باز می‌کنید، کاسکید همچنان محتوای و نتایج بحث شده قبلی را "به یاد می‌آورد"، بدون اینکه شما مجبور باشید دوباره توضیح دهید. این معادل گسترش حافظه مکالمه به سبک ChatGPT به ابعاد بین‌نشستی است. از نظر پیاده‌سازی، حافظه‌ها باید از طریق یک پایگاه داده محلی یا فایل‌های پیکربندی کاربر پیاده‌سازی شوند و اطمینان حاصل شود که فقط کاربر یا تیم می‌تواند به آنها دسترسی داشته باشد. علاوه بر فهرست‌بندی جهانی و حافظه‌ها، ویندسرف یک منبع زمینه منحصر به فرد دارد: رفتار توسعه‌دهنده در زمان واقعی. از آنجایی که کاسکید به طور کامل در IDE ادغام شده است، می‌تواند اقدامات شما را در IDE در زمان واقعی درک کند. به عنوان مثال، موقعیت مکان‌نمای شما، کدی که در حال ویرایش آن هستید، یا دستورات ترمینالی که اجرا می‌کنید – کاسکید می‌تواند این اطلاعات را به دست آورده و آن را در زمینه مکالمه ادغام کند. کودیوم این را "آگاهی در زمان واقعی از اقدامات شما" می‌نامد. سناریویی را در نظر بگیرید: اگر شما تازه تست‌ها را اجرا کرده‌اید، کاسکید می‌تواند خروجی تست را بخواند، متوجه شود که یک تست واحد شکست خورده است و به صورت فعالانه یک راه حل پیشنهاد دهد – حتی اگر شما به صراحت گزارش شکست را برای آن کپی نکرده باشید. یا، اگر یک فایل کد فرانت‌اند را باز کنید، کاسکید بلافاصله آن فایل را می‌کشد و در پس‌زمینه آن را تجزیه و تحلیل می‌کند، به طوری که وقتی یک سوال مرتبط می‌پرسید، هیچ تأخیری وجود ندارد. این دنبال کردن لحظه‌ای عملیات انسانی، همکاری انسان و ماشین را طبیعی‌تر و روان‌تر می‌کند، گویی کاسکید دستیاری است که دائماً صفحه نمایش شما را تماشا می‌کند. به طور خلاصه، ویندسرف قوی‌ترین مدیریت زمینه IDE را که در حال حاضر موجود است، از طریق ترکیبی از فهرست‌بندی محلی + حافظه بین‌نشستی + آگاهی از محیط در زمان واقعی به دست می‌آورد، که کاسکید را تقریباً مانند یک برنامه‌نویس انسانی با "درک زمینه‌ای" می‌کند – دانستن تصویر کلی، به خاطر سپردن تاریخچه، و درک آنچه در حال حاضر انجام می‌دهید.

**ابزارها و سیستم پلاگین:** جعبه ابزار کاسکید شباهت‌های زیادی با کرسر/کوپایلوت دارد و همچنین از عملیات مختلف مرتبط با برنامه‌نویسی پشتیبانی می‌کند، از جمله: باز کردن/خواندن فایل‌ها، ویرایش و درج کد، اجرای دستورات شل، دسترسی به خروجی کامپایلر یا تست و غیره. تیم ویندسرف ترمینال را از ابتدا در جریان کاری کاسکید ادغام کرد و به عامل اجازه داد تا مستقیماً دستوراتی مانند ساخت، اجرا، نصب وابستگی‌ها و مهاجرت‌های پایگاه داده را صادر کند و سپس بر اساس خروجی اقدامات بعدی را انجام دهد. قابل ذکر است که کودیوم پشتیبانی از پروتکل زمینه مدل (Model Context Protocol - MCP) را نیز اضافه کرده است. در به‌روزرسانی Windsurf Wave 3 که در فوریه ۲۰۲۵ منتشر شد، ادغام MCP به یک نقطه عطف مهم تبدیل شد. با ویرایش `~/.codeium/windsurf/mcp_config.json`، کاربران می‌توانند سرویس‌های MCP خارجی را برای فراخوانی توسط کاسکید ثبت کنند. به عنوان مثال، مثال رسمی نشان می‌دهد که چگونه یک پلاگین Google Maps MCP را پیکربندی کنید: ارائه یک فرمان سرویس برای اجرای `@modelcontextprotocol/server-google-maps` و یک کلید API، سپس کاسکید ابزار جدیدی به دست می‌آورد که می‌تواند بر اساس اطلاعات جغرافیایی به کدنویسی کمک کند. اساساً، MCP یک کانال برای اتصال داده به هر سرویس شخص ثالث را برای ویندسرف فراهم می‌کند، با استفاده از JSON برای پیکربندی، که امن و قابل کنترل است (کاربران سازمانی می‌توانند محدود کنند که کدام سرویس‌های MCP در دسترس هستند). علاوه بر MCP، ویندسرف افزونه‌هایی مانند حالت فرمان (Command Mode) نیز دارد: توسعه‌دهندگان می‌توانند برخی از دستورات IDE را مستقیماً از طریق کلمات کلیدی خاص صادر کنند و کاسکید این دستورات را برای انجام اقدامات مربوطه یا ارائه نتایج تجزیه و تحلیل می‌کند. در معرفی رسمی کودیوم، ویندسرف مجموعه‌ای از الگوهای "فلوهای هوش مصنوعی" (AI Flows) را ارائه می‌دهد که می‌توانند با یک کلیک فعال شوند، مانند فلو بررسی کیفیت کد، فلو رفع خودکار باگ و غیره، که همه توسط کاسکید در پس‌زمینه ارکستراسیون می‌شوند. شایان ذکر است که ویندسرف در عین توانمندسازی عامل با قابلیت‌های قوی، توجه زیادی به مجوزهای کاربر و تجربه کاربری دارد. به عنوان مثال، نیاز قبلاً ذکر شده برای تأیید تفاوت‌ها (diffs) توسط کاربر برای جلوگیری از عملکرد خودسرانه عامل و ایجاد مشکل است. همچنین، کاسکید اغلب قبل از فراخوانی یک ابزار، قصد خود را در مکالمه توضیح می‌دهد و وضعیت خود را در طول عملیات زمان‌بر به‌روزرسانی می‌کند (کرسر بعداً استراتژی مشابهی را اتخاذ کرد). این جزئیات باعث می‌شود کاربران احساس کنند که کاسکید در حال "همکاری" است نه اینکه به عنوان یک جعبه سیاه عمل کند.

**مصالحه‌ها و نوآوری‌های کلیدی طراحی:** تولد ویندسرف/کاسکید، تا حدی، بازتاب و بهبود رویکرد "برنامه‌نویسی کاملاً خودکار هوش مصنوعی" است. تیم کودیوم اشاره می‌کند که برخی از نمونه‌های اولیه عامل تلاش کردند تا کل فرآیند برنامه‌نویسی را به دست بگیرند، اما اغلب کاربران را برای مدت طولانی منتظر می‌گذاشتند و کیفیت نتایج رضایت‌بخش نبود و نیاز به زمان بیشتری برای بازبینی و اصلاح داشت. برای رفع این مشکل، آنها مفهوم فلوها را معرفی کردند که برای اولین بار در نوامبر ۲۰۲۴ منتشر شد و به طور ظریفی فعالیت هوش مصنوعی را با کنترل توسعه‌دهنده ترکیب می‌کند. این نوآوری به کاسکید اجازه می‌دهد تا به طور مداوم اقدامات توسعه‌دهنده را درک کند و همکاری فوری را امکان‌پذیر سازد: به جای اینکه هوش مصنوعی به مدت ۱۰ دقیقه به صورت ایزوله کار کند، بهتر است هر چند ثانیه یک بار بر اساس بازخورد شما جهت خود را تنظیم کند. حالت فلوها "دوره‌های خلاء هوش مصنوعی" را کاهش می‌دهد و کارایی تعامل را بهبود می‌بخشد که نشان‌دهنده یک پیشرفت بزرگ برای ویندسرف در تجربه کاربری است. دوم، ویندسرف الزامات سازمانی را به عمق ادغام می‌کند. آنها انتخاب کردند که مدل‌ها را خود توسعه دهند و استقرار خصوصی را ارائه دهند، که به شرکت‌های بزرگ اجازه می‌دهد زیرساخت هوش مصنوعی خود را "مالک" باشند. از منظر مهندسی، این بدان معناست که ویندسرف باید مجموعه‌ای از مشکلات مانند بهینه‌سازی مدل، استقرار کانتینری و همکاری تیمی را حل کند، اما همچنین یک مانع رقابتی ایجاد می‌کند. در محیط‌هایی با الزامات سختگیرانه حریم خصوصی و انطباق، ویندسرف قابل استقرار محلی جذاب‌تر از کوپایلوت/کرسر صرفاً ابری است. علاوه بر این، قابلیت ادغام زمینه که توسط کاسکید نشان داده شده، یک نوآوری بزرگ است. از طریق فهرست‌بندی محلی + حافظه + نظارت در زمان واقعی، کودیوم جامع‌ترین مدیریت وضعیت هوش مصنوعی را که نزدیک‌ترین به تفکر برنامه‌نویس انسانی است، در صنعت به دست آورده است. این معماری نیاز به تغییرات قابل توجهی در IDE و مکانیزم‌های پیچیده همگام‌سازی اطلاعات دارد، اما یک دستیار هوش مصنوعی را به ارمغان می‌آورد که "به طور کامل" زمینه توسعه را درک می‌کند و بار جابجایی و پرامپتینگ کاربران را به شدت کاهش می‌دهد. در نهایت، ملاحظات ویندسرف برای امنیت و قابلیت اطمینان نیز منعکس‌کننده هوش مهندسی است. این سیستم پیش‌فرض قرار می‌دهد که هوش مصنوعی باید قبل از ارائه نتایج، تست‌ها را پشت سر بگذارد؛ اگر تغییرات هوش مصنوعی در تست‌ها شکست بخورند، کاسکید به صورت فعالانه آن را نشان می‌دهد حتی اگر کاربر مشکل را نبیند، که معادل داشتن یک بازبین کیفیت هوش مصنوعی داخلی است. علاوه بر این، درخواست تأیید نهایی تغییرات توسط کاربر، در حالی که به ظاهر یک مرحله اضافه می‌کند، در واقع ثابت شده است که یک بافر ضروری برای اکثر تیم‌های توسعه است و همچنین اقدامات جسورانه هوش مصنوعی را اطمینان‌بخش‌تر می‌کند. به طور خلاصه، سیستم عامل ویندسرف به فلسفه **"اتوماسیون انسان‌محور"** پایبند است: اجازه دادن به هوش مصنوعی تا حد امکان فعال باشد بدون واگذاری بیش از حد اختیارات، دستیابی به هم‌آفرینی انسان و هوش مصنوعی از طریق اشکال تعاملی جدید (فلوها)، و دادن کنترل کامل به کاربران بر مدل و استقرار. اینها عوامل کلیدی در جذب سریع میلیون‌ها کاربر در رقابت شدید هستند.

### خلاصه مقایسه سیستم‌ها

در ادامه جدولی ارائه شده است که مروری بر شباهت‌ها و تفاوت‌ها در معماری‌های عامل (Agent) گیت‌هاب کوپایلوت (GitHub Copilot)، کرسر (Cursor) و ویندسرف (Windsurf) را نشان می‌دهد:

| بُعد ویژگی                     | گیت‌هاب کوپایلوت (GitHub Copilot)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | کرسر (Cursor)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | ویندسرف (Windsurf) (کودیوم - Codeium)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **موقعیت معماری**              | به عنوان یک ربات چت برای کمک برنامه‌نویسی آغاز شد، به "حالت عامل" (نام کد: پروژه پاداوان) گسترش یافت؛ عامل می‌تواند در پلتفرم گیت‌هاب تعبیه شود، با گردش کارهای Issues/PR ادغام شود. مکالمه چند مرحله‌ای با یک عامل، بدون معماری صریح چند عاملی. از ورودی چندوجهی (تصاویر) پشتیبانی می‌کند.                                                                                                                                                                                                                                                                                                                                                                        | ویرایشگر محلی مبتنی بر هوش مصنوعی (مشتق VS Code)، شامل حالت چت و تعاملات حالت عامل. حالت دستیار پیش‌فرض بر پرسش و پاسخ و تکمیل تمرکز دارد، حالت عامل برای اجرای خودکار وظایف توسط هوش مصنوعی نیاز به فعال‌سازی صریح دارد. معماری تک عاملی، بدون پردازش چندوجهی.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | از ابتدا به عنوان یک "IDE عامل‌محور" طراحی شده است: دستیار هوش مصنوعی Cascade همیشه آنلاین است، قادر به چت و عملیات خودکار چند مرحله‌ای است، بدون نیاز به تغییر حالت. اجرای تک عاملی، همکاری همزمان بین انسان و هوش مصنوعی را از طریق Flows به دست می‌آورد، در حال حاضر بر متن کد تمرکز دارد.                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| **برنامه‌ریزی و اجرای وظایف**  | از تجزیه خودکار وظایف و اجرای تکراری پشتیبانی می‌کند. عامل درخواست‌های کاربر را به زیروظایف تقسیم کرده و آن‌ها را به صورت تکراری تکمیل می‌کند تا زمانی که هدف حاصل شود یا صراحتاً متوقف شود. دارای قابلیت‌های خود-ترمیم‌کنندگی (می‌تواند خطاهای کامپایل/تست را شناسایی و رفع کند). نتایج را پس از تکمیل هر وظیفه به صورت PR ارائه می‌دهد و منتظر بازبینی انسانی می‌ماند؛ بازخورد بازبینی، تکرار بعدی را آغاز می‌کند.                                                                                                                                                                                                                                               | می‌تواند تغییرات بین فایل‌ها را مدیریت کند اما بیشتر به سمت اجرای تک مرحله‌ای متمایل است: عامل دستورالعمل‌ها را دریافت کرده و تمام پیشنهادات تغییر را به یکباره ارائه می‌دهد، تفاوت‌ها را برای تأیید کاربر لیست می‌کند. معمولاً به صورت خودکار در چند مرحله تکرار نمی‌کند (مگر اینکه کاربر دوباره پرامپت کند)، و خطاها اغلب به کاربر واگذار می‌شود تا تصمیم بگیرد که آیا هوش مصنوعی آن‌ها را رفع کند یا خیر. به صورت پیش‌فرض تنها تعداد محدودی چرخه تصحیح خودکار را انجام می‌دهد تا از توقف نامحدود جلوگیری شود.                                                                                                                                                                                                                                     | استقلال عمیق: Cascade می‌تواند الزامات سطح بالا را به مجموعه‌ای از اقدامات تقسیم کرده و به طور مداوم اجرا کند تا وظیفه تکمیل شود. در بازسازی‌های بزرگ و وظایف بین ماژولی عالی عمل می‌کند، به صورت خودکار فراخوانی‌ها را برای ویرایش، ایجاد فایل، اجرای دستور، تأیید تست و غیره زنجیره‌ای می‌کند تا زمانی که کد از بررسی‌های خودکار عبور کند. اگر مشکلات جدیدی در طول فرآیند یافت شود، به تکرار و رفع آن‌ها ادامه می‌دهد و تقریباً به هیچ دخالت انسانی به جز نتیجه نهایی نیاز ندارد (اما تغییرات حیاتی نیاز به تأیید نهایی انسانی خواهند داشت).                                                                                                                                                                                                                     |
| **استراتژی مدل**               | ترکیب چند مدل ابری: از سری OpenAI GPT-4، GPT-3.5 (نام‌های کد داخلی o1، o3-mini و غیره)، Anthropic Claude 3.5، Google Gemini 2.0 و غیره پشتیبانی می‌کند، و کاربران می‌توانند مدل‌های ترجیحی را در رابط کاربری تغییر دهند. کارایی را از طریق معماری دو مدلی بهبود می‌بخشد (مدل بزرگ راه‌حل‌ها را تولید می‌کند، مدل کوچک به سرعت تغییرات را اعمال می‌کند). مدل‌ها به صورت یکپارچه توسط گیت‌هاب میزبانی و فراخوانی می‌شوند؛ درخواست‌های کاربران Copilot Enterprise از طریق نمونه‌های اختصاصی انجام می‌شود. از استقرار خصوصی پشتیبانی نمی‌کند.                                                                                                                          | کاملاً به APIهای مدل‌های بزرگ شخص ثالث متکی است: تمام درخواست‌ها از طریق ابر کرسر منتقل شده و مدل‌های OpenAI/Anthropic را فراخوانی می‌کنند. کاربران می‌توانند از کلیدهای API خود استفاده کنند (مدیریت صورتحساب توسط کاربر) اما فراخوانی همچنان در سرورهای رسمی انجام می‌شود. بدون گزینه‌های مدل آفلاین یا محلی. انواع مدل به دامنه پشتیبانی شده توسط کرسر بستگی دارد؛ کاربران نمی‌توانند آزادانه مدل‌های جدید را ادغام کنند. کرسر مستقیماً مدل‌ها را آموزش نمی‌دهد بلکه مدل‌های خارجی را با بهینه‌سازی پرامپت‌ها تطبیق می‌دهد.                                                                                                                                                                                                                       | مدل‌های عمدتاً خودتوسعه‌یافته، بک‌اند انعطاف‌پذیر: به صورت پیش‌فرض از مدل‌های کد اختصاصی کودیوم استفاده می‌کند، و به کاربران سازمانی اجازه می‌دهد استقرار خود-میزبانی شده را انتخاب کنند. معماری از تغییر موتورهای مدل مختلف (مدل "Sonnet" کودیوم یا منبع باز و غیره) پشتیبانی می‌کند، و می‌تواند در آینده رابط‌های شخص ثالث را گسترش دهد. برخی توابع سبک از مدل‌های کوچک برای محاسبات محلی/لبه‌ای برای کاهش تأخیر استفاده می‌کنند. بر کنترل کاربر بر محیط هوش مصنوعی تأکید دارد (سرعت به‌روزرسانی مدل، پایداری نسخه توسط کاربر کنترل می‌شود).                                                                                                                                                                                                                     |
| **زمینه و حافظه**              | از استراتژی RAG برای به دست آوردن زمینه کد استفاده می‌کند: قطعه کدهای مرتبط را از طریق GitHub Code Search بازیابی کرده و آن‌ها را به پرامپت‌ها تزریق می‌کند. پرامپت‌ها شامل خلاصه ساختار پروژه به جای متن کامل برای صرفه‌جویی در توکن‌ها هستند. از گنجاندن توضیحات Issue، بحث‌های PR مرتبط در زمینه برای درک هدف وظیفه و استانداردهای پروژه پشتیبانی می‌کند. تاریخچه مکالمه در یک جلسه واحد حفظ می‌شود؛ بدون حافظه خودکار بین جلسات (نیاز به اتکا به Issues/PRs یا READMEs برای حمل اطلاعات بین جلسات).                                                                                                                                                            | هنگام راه‌اندازی، شاخص برداری برای پروژه می‌سازد تا از جستجوی معنایی پشتیبانی کند. پرامپت‌های مدل بر زمینه کدی که کاربر در حال حاضر ارائه می‌دهد (فایل‌های باز یا قطعه کدها) تمرکز دارند؛ هنگامی که بخش‌های دیگری مورد نیاز است، از طریق ارتباط معنایی بازیابی و درج می‌شوند. مکانیزم فایل `.cursor/rules` را فراهم می‌کند، که به توسعه‌دهندگان اجازه می‌دهد دانش و استانداردهای دائمی برای پروژه تنظیم کنند؛ عامل این قوانین را در هر مکالمه می‌خواند، معادل حافظه بلندمدت ارائه شده توسط انسان. بدون حافظه خودکار بین جلسات به صورت پیش‌فرض (نیاز به ضبط دستی کاربر در فایل‌های قوانین).                                                                                                                                                           | نمایه‌سازی معنایی کامل پروژه: به صورت محلی کل پایگاه کد را پیش‌اسکن می‌کند تا یک شاخص بسازد؛ Cascade می‌تواند محتوای هر فایلی را به عنوان زمینه در هر زمان بازیابی کند. دارای یک سیستم حافظه است که به صورت خودکار و پایدار محتوای مکالمه مهم و یادداشت‌ها/قوانین مشخص شده توسط کاربر را ذخیره می‌کند، که به حافظه بین جلسات دست می‌یابد. بنابراین، Cascade حتی پس از راه‌اندازی مجدد، قراردادهای پروژه و بحث‌های قبلی را "به خاطر می‌آورد". همچنین وضعیت محیط IDE را به عنوان منبع زمینه ادغام می‌کند: درک بلادرنگ فایل‌های باز شده توسط کاربر، موقعیت مکان‌نما، خروجی ترمینال و غیره، با استفاده از این اطلاعات ضمنی برای درک قصد کاربر. در مجموع، Cascade دیدگاه زمینه‌ای گسترده‌تر و پویاتری دارد.                                                             |
| **ابزارها و افزونه‌ها**        | ادغام عمیق با گردش کار گیت‌هاب: عامل یک محیط توسعه ایزوله در ابر را از طریق GitHub Actions به دست می‌آورد، قادر به اجرای تست‌های واحد، اجرای پروژه‌ها و غیره. ابزارهای داخلی شامل خواندن فایل‌ها، جستجوی مخازن، اعمال تغییرات کد، دستورات ترمینال و غیره هستند که LLM می‌تواند در صورت نیاز فراخوانی کند. استاندارد MCP (Model Context Protocol) را معرفی می‌کند، که از اتصال به منابع داده و خدمات خارجی پشتیبانی می‌کند؛ افزونه‌های رسمی MCP می‌توانند به داده‌های گیت‌هاب دسترسی داشته باشند، و یک رابط باز جهانی برای افزونه‌های شخص ثالث. دارای قابلیت‌های بینایی کامپیوتر است، می‌تواند اسکرین‌شات‌های پیوست شده به Issues را به عنوان مبنای مشکل تجزیه کند. | ابزارهای غنی دستکاری IDE را فراهم می‌کند، دقیقاً توسط پرامپت‌های سیستمی در مورد نحوه استفاده از آن‌ها هدایت می‌شود (مثلاً نیاز به خواندن محتوای فایل توسط هوش مصنوعی قبل از تغییر، جلوگیری از نوشتن کورکورانه بدون اتکا به زمینه). قابلیت افزونه‌پذیری را از طریق رابط MCP به دست می‌آورد، که امکان اتصال به ابزارها/منابع داده سفارشی برای گسترش قابلیت‌های عامل را فراهم می‌کند. به عنوان مثال، توسعه‌دهندگان می‌توانند یک افزونه پرس و جوی پایگاه داده اضافه کنند تا به عامل کرسر اجازه دهند از آخرین اطلاعات شمای پایگاه داده در کد استفاده کند. عامل کرسر به شدت از قوانین از پیش تعریف شده برای استفاده از ابزار پیروی می‌کند (مثلاً توضیح اقدامات قبل از فراخوانی)، که قابلیت پیش‌بینی تعامل را بهبود می‌بخشد.                                | جامع‌ترین ادغام ابزار: Cascade کنترل عملیاتی گسترده‌ای بر ویرایشگر و سیستم، از سیستم فایل تا ترمینال، دارد. از اجرای خودکار دستورات (مثلاً ساخت، تست) و استفاده از نتایج برای اقدامات بعدی پشتیبانی می‌کند. از Wave 3 به بعد از افزونه‌های MCP پشتیبانی می‌کند، که به خدمات خارجی اجازه می‌دهد از طریق پیکربندی JSON به ابزارهای Cascade تبدیل شوند، مانند APIهای نقشه، رابط‌های پایگاه داده و غیره. Cascade همچنین وضعیت IDE (محتوای کلیپ‌بورد، انتخاب فعلی و غیره) را برای پاسخ‌های هوشمندتر نظارت می‌کند. برای امنیت، ویندسرف برای تغییرات حیاتی نیاز به تأیید کاربر و برای فراخوانی خدمات خارجی نیاز به پیکربندی قبلی برای جلوگیری از سوء استفاده دارد. در مجموع، Cascade تقریباً معادل یک شریک توسعه هوش مصنوعی با قابلیت‌های افزونه IDE و اسکریپت Shell است. |
| **مصالحه‌های مهندسی و نوآوری** | ادغام پلتفرم: به طور کامل از زیرساخت‌های موجود گیت‌هاب (Actions، مکانیزم‌های PR و غیره) برای میزبانی عامل بهره می‌برد. امنیت در اولویت: سیاست‌های داخلی برای جلوگیری از تأثیر مستقیم کد بررسی نشده بر شاخه اصلی و محیط تولید. استاندارد باز MCP را پیشنهاد کرد، پیشگام در اکتشاف صنعتی یک راه‌حل جهانی برای فراخوانی ابزارهای خارجی توسط LLMها. شفافیت: به کاربران اجازه می‌دهد گزارش‌های اجرای عامل را مشاهده کنند تا فرآیند تصمیم‌گیری آن را درک کنند، که اعتماد را افزایش می‌دهد. نوآوری در ادغام عمیق هوش مصنوعی در مراحل مختلف گردش کار توسعه برای دستیابی به توسعه مشارکتی انسان-هوش مصنوعی با حلقه بسته است.                                                | سرویس ابری: معماری ابری انتخاب شده عملکرد مدل بزرگ و مدیریت یکپارچه را تضمین می‌کند، اما قابلیت آفلاین را قربانی می‌کند. پرامپت‌های بهینه‌سازی شده: تبدیل LLMها به دستیاران کد حرفه‌ای به مجموعه وسیعی از پرامپت‌های سیستمی و دستورالعمل‌های ابزار متکی است؛ سرمایه‌گذاری کرسر در این زمینه کیفیت تولید آن را بسیار تحسین‌برانگیز کرده است. نظارت انسانی: یک مرحله اضافی تأیید انسانی را ترجیح می‌دهد تا دادن آزادی کامل به هوش مصنوعی برای تغییر کد—این استراتژی محافظه‌کارانه خطر خطا را کاهش می‌دهد و اعتماد کاربر را افزایش می‌دهد. قابلیت سفارشی‌سازی: از طریق فایل‌های قوانین و افزونه‌ها، کرسر راه‌هایی را برای کاربران پیشرفته برای سفارشی‌سازی رفتار هوش مصنوعی و گسترش قابلیت‌ها فراهم می‌کند، که یک مزیت عمده در انعطاف‌پذیری مهندسی است. | انسان‌محور: حالت Flows را برای مقابله با کارایی پایین اجرای ناهمزمان عامل اولیه معرفی کرد، که امکان تعامل بلادرنگ بین اقدامات هو                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
