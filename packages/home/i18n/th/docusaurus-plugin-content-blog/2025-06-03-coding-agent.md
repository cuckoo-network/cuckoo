---
title: "สถาปัตยกรรมระบบเอเจนต์ของ GitHub Copilot, Cursor และ Windsurf"
tags: [AI, ผู้ช่วยเขียนโปรแกรม, GitHub Copilot, Cursor, Windsurf, ระบบเอเจนต์]
keywords: [สถาปัตยกรรม AI, GitHub Copilot, Cursor, Windsurf, ผู้ช่วยเขียนโปรแกรม, ระบบเอเจนต์, การแบ่งงาน, การเรียกใช้โมเดล, การจัดการบริบท]
authors: [lark]
description: การวิเคราะห์เชิงลึกเกี่ยวกับสถาปัตยกรรมระบบเอเจนต์ของ GitHub Copilot, Cursor และ Windsurf โดยเน้นที่ปรัชญาการออกแบบ, การแบ่งงาน, กลยุทธ์การเรียกใช้โมเดล และการจัดการบริบท เพื่อทำความเข้าใจผลกระทบของสิ่งเหล่านี้ต่อการช่วยเหลือการเขียนโปรแกรมที่ขับเคลื่อนด้วย AI
image: "https://opengraph-image.blockeden.xyz/api/og-cuckoo-network?title=สถาปัตยกรรมระบบเอเจนต์ของ%20GitHub%20Copilot%2C%20Cursor%20และ%20Windsurf"
---

## สถาปัตยกรรมระบบ Agent ของ GitHub Copilot, Cursor และ Windsurf

ในช่วงไม่กี่ปีที่ผ่านมา ผลิตภัณฑ์ผู้ช่วยเขียนโค้ดด้วย AI หลายตัวได้ถือกำเนิดขึ้น เช่น GitHub Copilot, Cursor และ Windsurf การนำไปใช้งานของผลิตภัณฑ์เหล่านี้ล้วนนำเสนอแนวคิดของ "Agent" (intelligent agent) ซึ่งช่วยให้ AI สามารถช่วยเหลือการทำงานด้านการเขียนโค้ดได้อย่างเชิงรุกมากขึ้น บทความนี้จะนำเสนอการสำรวจเชิงลึกเกี่ยวกับการสร้างระบบ Agent ของผลิตภัณฑ์เหล่านี้จากมุมมองสถาปัตยกรรมทางวิศวกรรม รวมถึงปรัชญาการออกแบบสถาปัตยกรรม, การแยกย่อยและวางแผนงาน, กลยุทธ์การเรียกใช้โมเดล, การจัดการสถานะบริบท, กลไกการขยายปลั๊กอิน, และข้อดีข้อเสียที่สำคัญ รวมถึงนวัตกรรมในการออกแบบของแต่ละผลิตภัณฑ์ เนื้อหาต่อไปนี้อ้างอิงจากบล็อกวิศวกรรมอย่างเป็นทางการ, บทความจากนักพัฒนาโครงการ, และเอกสารทางเทคนิคที่เกี่ยวข้องเป็นหลัก

![](https://opengraph-image.blockeden.xyz/api/og-cuckoo-network?title=สถาปัตยกรรมระบบ%20Agent%20ของ%20GitHub%20Copilot%2C%20Cursor%20และ%20Windsurf)

### สถาปัตยกรรม Agent ของ GitHub Copilot

**ปรัชญาการออกแบบสถาปัตยกรรม:** GitHub Copilot เริ่มแรกวางตำแหน่งตัวเองเป็น "AI คู่หูโปรแกรมเมอร์" สำหรับนักพัฒนา และตอนนี้ได้ขยายขีดความสามารถด้วยโหมด "Agent" ระบบ Agent ของมันไม่ใช่การรวมกันของ Agent อิสระหลายตัว แต่เป็น Agent อัจฉริยะแบบฝังตัวที่สามารถสนทนาแบบหลายรอบและดำเนินการงานแบบหลายขั้นตอนได้ รองรับอินพุตแบบหลายโมดัล (เช่น การใช้โมเดลวิชันเพื่อตีความภาพหน้าจอ) Copilot เน้นย้ำการช่วยเหลือด้วย AI มากกว่าการเข้ามาแทนที่นักพัฒนา ในโหมด Agent มันทำหน้าที่เหมือนวิศวกรอัตโนมัติภายในทีม โดยรับมอบหมายงาน เขียนโค้ด แก้ไขข้อบกพร่อง และส่งผลลัพธ์ผ่าน Pull Request ได้ด้วยตัวเอง Agent นี้สามารถเรียกใช้งานได้ผ่านอินเทอร์เฟซแชท หรือโดยการมอบหมาย GitHub Issue ให้กับ Copilot

**การแยกย่อยงานและการวางแผน:** Agent ของ Copilot มีความสามารถโดดเด่นในการแยกย่อยงานซอฟต์แวร์ที่ซับซ้อนออกเป็นงานย่อย ๆ และดำเนินการให้เสร็จทีละขั้นตอน โดยใช้กระบวนการให้เหตุผลภายในที่คล้ายกับ Chain-of-Thought มันจะวนซ้ำผ่าน "วิเคราะห์ปัญหา → ดำเนินการแก้ไขโค้ดหรือคำสั่ง → ตรวจสอบผลลัพธ์" จนกว่าจะตรงตามความต้องการของผู้ใช้ ตัวอย่างเช่น ในโหมด Agent, Copilot ไม่เพียงแต่ดำเนินการตามขั้นตอนที่ผู้ใช้ระบุเท่านั้น แต่ยัง _อนุมาน_ และดำเนินการขั้นตอนเพิ่มเติมที่จำเป็นเพื่อให้บรรลุเป้าหมายหลักโดยอัตโนมัติ หากเกิดข้อผิดพลาดในการคอมไพล์หรือการทดสอบล้มเหลวในระหว่างกระบวนการ Agent จะระบุและแก้ไขข้อผิดพลาดด้วยตัวเอง และลองใหม่อีกครั้ง ทำให้นักพัฒนาไม่ต้องคัดลอกและวางข้อความแสดงข้อผิดพลาดซ้ำ ๆ เป็นพรอมต์ บล็อกของ VS Code สรุปวงจรการทำงานของมันว่า: Copilot Agent จะพิจารณาบริบทและไฟล์ที่เกี่ยวข้องที่ต้องแก้ไข เสนอการปรับเปลี่ยนโค้ดและคำสั่งที่จะรัน ตรวจสอบความถูกต้องของการแก้ไขหรือเอาต์พุตของเทอร์มินัล และวนซ้ำอย่างต่อเนื่องจนกว่างานจะเสร็จสมบูรณ์ การดำเนินการแบบหลายรอบอัตโนมัตินี้ช่วยให้ Copilot สามารถจัดการงานได้หลากหลาย ตั้งแต่การสร้างแอปพลิเคชันง่าย ๆ ไปจนถึงการปรับโครงสร้างโค้ดขนาดใหญ่ในหลายไฟล์

**กลยุทธ์การเรียกใช้โมเดล:** โมเดลที่อยู่เบื้องหลัง GitHub Copilot เดิมคือ OpenAI's Codex ซึ่งปัจจุบันได้รับการอัปเกรดเป็นสถาปัตยกรรมแบบหลายโมเดลที่ทรงพลังยิ่งขึ้น Copilot อนุญาตให้ผู้ใช้เลือกโมเดลพื้นฐานที่แตกต่างกันใน "ตัวเลือกโมเดล" เช่น GPT-4 ของ OpenAI (ชื่อรหัสภายใน gpt-4o) และเวอร์ชันที่เรียบง่ายกว่า, Claude 3.5 ของ Anthropic (ชื่อรหัส Sonnet) และ Gemini 2.0 Flash ล่าสุดของ Google เป็นต้น การรองรับหลายโมเดลนี้หมายความว่า Copilot สามารถสลับแหล่งที่มาของโมเดลได้ตามความต้องการของงานหรือความชอบของผู้ใช้ ในฟังก์ชัน Copilot Edits (การแก้ไขหลายไฟล์) GitHub ยังใช้สถาปัตยกรรมแบบสองโมเดลเพื่อปรับปรุงประสิทธิภาพ: ประการแรก "โมเดลขนาดใหญ่" ที่เลือกจะสร้างแผนการแก้ไขเบื้องต้นพร้อมบริบททั้งหมด จากนั้นปลายทาง "การถอดรหัสแบบคาดการณ์" ที่เชี่ยวชาญจะนำการเปลี่ยนแปลงเหล่านี้ไปใช้อย่างรวดเร็ว ตัวถอดรหัสแบบคาดการณ์สามารถมองได้ว่าเป็นโมเดลน้ำหนักเบาหรือเอนจินกฎที่สร้างผลลัพธ์การแก้ไขล่วงหน้าในขณะที่โมเดลขนาดใหญ่กำลังพิจารณาการเปลี่ยนแปลงโค้ด ซึ่งช่วยลดความหน่วง โดยสรุป กลยุทธ์โมเดลของ Copilot คือการรวม LLM ล้ำสมัยหลายตัวเข้าด้วยกันในคลาวด์ ซึ่งได้รับการปรับให้เหมาะสมสำหรับสถานการณ์ที่แตกต่างกัน และสร้างสมดุลระหว่างความเร็วในการตอบสนองและความแม่นยำผ่านวิธีการทางวิศวกรรม (ไปป์ไลน์แบบสองโมเดล)

**การจัดการสถานะและการคงบริบท:** Copilot Agent ให้ความสำคัญอย่างยิ่งกับการใช้ประโยชน์จากบริบทการพัฒนา เนื่องจากการให้โค้ดของทั้ง repository เป็นอินพุตโดยตรงแก่โมเดลขนาดใหญ่เป็นเรื่องที่ไม่สามารถทำได้จริง Copilot จึงใช้กลยุทธ์ **Retrieval-Augmented Generation (RAG)**: โดยจะค้นหาเนื้อหาที่เกี่ยวข้องภายใน repository โดยใช้เครื่องมือเช่น GitHub Code Search และแทรกส่วนย่อยโค้ดที่ดึงมาได้เข้าสู่บริบทของโมเดลแบบไดนามิก เมื่อ Agent เริ่มทำงาน มันจะโคลนโค้ดโปรเจกต์ไปยังสภาพแวดล้อมที่แยกต่างหาก และวิเคราะห์โครงสร้างโค้ดเบสก่อน สร้างสรุปที่จำเป็นเพื่อประหยัดโทเค็น ตัวอย่างเช่น พรอมต์ที่สร้างโดย Copilot อาจรวมถึง "สรุปโครงสร้างไฟล์โปรเจกต์ + เนื้อหาไฟล์หลัก + คำขอของผู้ใช้" สิ่งนี้ช่วยให้โมเดลเข้าใจภาพรวมเมื่อสร้างโซลูชันโดยไม่เกินขีดจำกัดความยาวของบริบท ในระหว่างการสนทนา Copilot ยังติดตามประวัติเซสชัน (เช่น คำแนะนำที่ผู้ใช้เคยให้ไว้ในแชท) เพื่อรักษาความต่อเนื่อง ในขณะเดียวกัน Copilot ก็ถูกรวมเข้ากับแพลตฟอร์ม GitHub อย่างลึกซึ้ง ทำให้สามารถใช้คำอธิบาย Issue, การสนทนา PR ที่เกี่ยวข้อง ฯลฯ เป็นบริบทเพิ่มเติมได้ โดยเฉพาะอย่างยิ่ง หาก repository มีไฟล์การกำหนดค่าที่ระบุมาตรฐานการเขียนโค้ดหรือคำแนะนำก่อนหน้าสำหรับการใช้ AI, Agent ก็จะปฏิบัติตามคำแนะนำ repository ที่กำหนดเองเหล่านี้ด้วย สิ่งสำคัญคือ Copilot เองไม่มีหน่วยความจำระยะยาวของโค้ดผู้ใช้—มันไม่ได้บันทึกสถานะโดยอัตโนมัติเกินกว่าแต่ละเซสชันสำหรับเซสชันถัดไป (เว้นแต่ผู้ใช้จะฮาร์ดโค้ดไว้ในเอกสาร) อย่างไรก็ตาม ผ่านกลไก Issue/PR ของ GitHub ผู้ใช้สามารถให้คำอธิบายงานและภาพหน้าจอที่คงอยู่กับ Agent ได้อย่างมีประสิทธิภาพ ซึ่งสามารถมองได้ว่าเป็นวิธีการนำบริบทติดตัวไปด้วย

**ระบบปลั๊กอินและกลไกส่วนขยาย:** GitHub Copilot Agent ดำเนินการบน IDE และสภาพแวดล้อมภายนอกผ่านการเรียกใช้เครื่องมือ (Tool Use) ในด้านหนึ่ง ในสภาพแวดล้อมแบบ local หรือ Codespaces, Copilot สามารถเรียกใช้ API ที่จัดทำโดยส่วนขยายของ VS Code เพื่อดำเนินการต่างๆ เช่น การอ่านไฟล์, การเปิด Editor, การแทรกส่วนย่อยโค้ด และการรันคำสั่ง Terminal ในอีกด้านหนึ่ง GitHub ได้นำเสนอ **Model Context Protocol (MCP)** เพื่อขยาย "วิสัยทัศน์" และความสามารถของ Agent MCP อนุญาตให้กำหนดค่า "เซิร์ฟเวอร์ทรัพยากร" ภายนอกได้ และ Agent สามารถร้องขอข้อมูลหรือการดำเนินการเพิ่มเติมผ่านอินเทอร์เฟซที่เป็นมาตรฐาน ตัวอย่างเช่น GitHub ได้จัดเตรียมเซิร์ฟเวอร์ MCP ของตนเองอย่างเป็นทางการ ทำให้ Agent สามารถรับข้อมูลเพิ่มเติมเกี่ยวกับ repository ปัจจุบันได้ (เช่น ผลการค้นหาโค้ด, Project Wiki เป็นต้น) กลไก MCP ยังรองรับบุคคลที่สาม: ตราบใดที่พวกเขานำอินเทอร์เฟซ MCP ไปใช้ Agent ก็สามารถเชื่อมต่อได้ เช่น การเรียกใช้บริการสืบค้นฐานข้อมูล หรือการส่งคำขอ HTTP Copilot Agent มีความสามารถแบบหลายโมดัลอยู่แล้วบางส่วน ด้วยการรวมเข้ากับโมเดลวิชัน มันสามารถวิเคราะห์ภาพหน้าจอ, แผนภาพการออกแบบ และรูปภาพอื่นๆ ที่ผู้ใช้แนบมาใน Issues เป็นอินพุตเสริมได้ ซึ่งหมายความว่าเมื่อแก้ไขข้อบกพร่องของ UI หรือจำลองข้อผิดพลาด นักพัฒนาสามารถให้ภาพหน้าจอแก่ Copilot ได้ และ Agent สามารถ "พูดจากภาพ" เพื่อเสนอคำแนะนำในการแก้ไขโค้ดที่เกี่ยวข้องได้ นอกจากนี้ หลังจากเสร็จสิ้นงาน Copilot Agent จะคอมมิตการเปลี่ยนแปลงผ่าน Git โดยอัตโนมัติและเปิด Draft PR จากนั้น **@mentions** นักพัฒนาที่เกี่ยวข้องเพื่อขอการรีวิว ความคิดเห็นและข้อเสนอแนะของผู้รีวิว (เช่น การขอให้แก้ไขการใช้งานบางอย่าง) ก็จะถูกอ่านโดย Agent และทำหน้าที่เป็นคำแนะนำใหม่ ซึ่งกระตุ้นให้เกิดการอัปเดตโค้ดรอบถัดไป กระบวนการทั้งหมดคล้ายกับการทำงานร่วมกันของนักพัฒนาที่เป็นมนุษย์: AI Agent ส่งโค้ด → มนุษย์รีวิวและให้ข้อเสนอแนะ → AI Agent ปรับปรุง เพื่อให้มั่นใจว่ามนุษย์ยังคงควบคุมได้เสมอ

**ข้อแลกเปลี่ยนด้านการออกแบบที่สำคัญและนวัตกรรม:** ระบบ Agent ของ GitHub Copilot ใช้ประโยชน์จากระบบนิเวศแพลตฟอร์ม GitHub ที่มีอยู่ได้อย่างเต็มที่ ซึ่งเป็นลักษณะสำคัญของมัน ในด้านหนึ่ง มันเลือกที่จะสร้างสภาพแวดล้อมการรันโค้ดบนคอนเทนเนอร์คลาวด์ของ GitHub Actions ซึ่งทำให้เกิดการแยกส่วนที่ดีและความสามารถในการปรับขนาด "Project Padawan" เป็นชื่อรหัสสำหรับสถาปัตยกรรมนี้ ซึ่งหลีกเลี่ยงการสร้างโครงสร้างพื้นฐานการรันใหม่ตั้งแต่ต้น และสร้างขึ้นบนระบบ CI/CD ที่เป็นผู้ใหญ่แล้วแทน ในอีกด้านหนึ่ง Copilot มีการแลกเปลี่ยนที่เข้มงวดในด้านความปลอดภัย: โดยค่าเริ่มต้น Agent สามารถพุชโค้ดไปยัง branch ที่สร้างขึ้นใหม่เท่านั้น ไม่สามารถแก้ไข main branch ได้โดยตรง และ PR ที่ถูกเรียกใช้งานจะต้องได้รับการอนุมัติจากผู้อื่นก่อนการรวม และ CI pipeline จะถูกหยุดชั่วคราวก่อนการอนุมัติ กลยุทธ์เหล่านี้ช่วยให้มั่นใจว่าการนำระบบอัตโนมัติของ AI มาใช้จะไม่รบกวนระบบการรีวิวและเกตการเผยแพร่ที่มีอยู่ของทีม การเสนอ Model Context Protocol สามารถมองได้ว่าเป็นนวัตกรรมทางวิศวกรรมที่สำคัญสำหรับ Copilot—มันกำหนดมาตรฐานเปิดสำหรับ LLM Agent ในการเข้าถึงเครื่องมือ/ข้อมูลภายนอก ทำให้แหล่งข้อมูลต่างๆ ทั้งภายในและภายนอก GitHub สามารถรวมเข้ากับพรอมต์ AI ได้อย่างราบรื่นในอนาคต นอกจากนี้ Copilot Agent ยังบันทึกบันทึกความคิด (session logs) ในระหว่างการดำเนินการ รวมถึงขั้นตอนที่ใช้ในการเรียกใช้เครื่องมือและเอาต์พุตที่สร้างขึ้น และนำเสนอข้อมูลเหล่านี้แก่นักพัฒนา ความโปร่งใสนี้ช่วยให้ผู้ใช้สามารถตรวจสอบ "ความคิด" และการกระทำของ Agent ได้ ซึ่งช่วยอำนวยความสะดวกในการแก้ไขข้อบกพร่องและการสร้างความไว้วางใจ โดยรวมแล้ว GitHub Copilot ได้ฝัง AI Agent เข้าไปในขั้นตอนต่างๆ ของวงจรการพัฒนา (การเขียนโค้ด -> การส่ง PR -> การรีวิวโค้ด) และด้วยชุดของการตัดสินใจทางสถาปัตยกรรม ทำให้เกิดการรวมระบบอัตโนมัติเข้ากับเวิร์กโฟลว์ที่มีอยู่ได้อย่างราบรื่น

### สถาปัตยกรรม Agent ของ Cursor

**ปรัชญาการออกแบบสถาปัตยกรรม:** Cursor เป็นเครื่องมือเขียนโค้ดที่ขับเคลื่อนด้วย AI ซึ่งพัฒนาโดยสตาร์ทอัพ Anysphere โดยพื้นฐานแล้วเป็นโปรแกรมแก้ไขโค้ด (ที่ปรับปรุงจาก VS Code) ซึ่งผสานรวมอย่างลึกซึ้งกับผู้ช่วย AI Cursor มีโหมดการโต้ตอบหลักสองโหมด: ผู้ช่วยแชทและ Agent อิสระ ในโหมดสนทนาปกติ มันทำหน้าที่เป็นผู้ช่วยโค้ดแบบดั้งเดิม โดยตอบคำถามหรือสร้างโค้ดตามคำสั่ง; เมื่อเปลี่ยนไปใช้โหมด Agent (หรือที่เรียกว่า "Composer") Cursor สามารถดำเนินการชุดคำสั่งเชิงรุกในนามของนักพัฒนาได้ สถาปัตยกรรมนี้ช่วยให้ผู้ใช้มีอิสระในการเลือกตามความต้องการ: งานง่ายๆ สามารถจัดการได้โดยการถามทีละบรรทัดในโหมดผู้ช่วย ในขณะที่งานที่ซับซ้อนหรือทำซ้ำสามารถประมวลผลเป็นชุดได้โดยการเรียกใช้ Agent ปัจจุบัน Cursor มุ่งเน้นหลักในการช่วยเหลือในโดเมนข้อความ (โค้ด) โดยไม่เน้นอินพุต/เอาต์พุตแบบหลายโมดัล (แม้ว่าจะให้ฟังก์ชันการป้อนข้อมูลด้วยเสียง โดยแปลงคำพูดเป็นข้อความสำหรับพรอมต์) คล้ายกับ Copilot ระบบ Agent ของ Cursor ก็ทำงานเป็น Agent อัจฉริยะเดี่ยวที่ทำงานแบบอนุกรม ไม่ใช่ Agent หลายตัวที่ทำงานแบบขนาน อย่างไรก็ตาม คุณสมบัติที่โดดเด่นคือการเน้นการทำงานร่วมกันระหว่างมนุษย์กับ AI: ในโหมด Agent, AI ดำเนินการให้มากที่สุดเท่าที่จะทำได้ แต่โดยรวมแล้วยังคงอนุญาตให้นักพัฒนาเข้าแทรกแซงและควบคุมได้ตลอดเวลา แทนที่จะทำงานโดยไม่มีการควบคุมดูแลอย่างสมบูรณ์เป็นเวลานาน

**การแยกย่อยและการวางแผนงาน:** ในโหมด Agent ของ Cursor, AI สามารถจัดการงานที่ซับซ้อนข้ามไฟล์ได้ แต่การออกแบบมุ่งเน้นไปที่รูปแบบการร้องขอทีละขั้นตอน หลังจากได้รับคำสั่งระดับสูงจากผู้ใช้ Agent จะค้นหาส่วนของโค้ดที่เกี่ยวข้องโดยอัตโนมัติ, เปิดไฟล์ที่ต้องแก้ไข, สร้างแผนการแก้ไข, และแม้กระทั่งรันการทดสอบ/คำสั่งบิลด์เพื่อตรวจสอบผลลัพธ์ อย่างไรก็ตาม ไม่เหมือนกับ Agent ของ Copilot หรือ Windsurf, Agent ของ Cursor โดยทั่วไปจะหยุดชั่วคราวหลังจากเสนอแนวคิดเริ่มต้นเสร็จสิ้น โดยรอการตรวจสอบจากผู้ใช้และคำแนะนำเพิ่มเติม ซึ่งหมายความว่า Agent ของ Cursor โดยทั่วไปจะไม่ปรับปรุงตัวเองอย่างต่อเนื่องและซ้ำๆ เว้นแต่จะได้รับพรอมต์ใหม่จากผู้ใช้ ตัวอย่างเช่น หากคุณขอให้ Cursor ทำการปรับโครงสร้างโค้ดข้ามโปรเจกต์ มันจะรวบรวมตำแหน่งทั้งหมดที่ต้องแก้ไขและสร้าง diff สำหรับแต่ละไฟล์ให้ผู้ใช้ตรวจสอบ ณ จุดนี้ ผู้ใช้จะตัดสินใจว่าจะยอมรับและใช้การเปลี่ยนแปลงใด หากการเปลี่ยนแปลงเหล่านี้ทำให้เกิดปัญหาใหม่ Cursor จะไม่ดำเนินการแก้ไขต่อไปโดยพลการ เว้นแต่ผู้ใช้จะร้องขอเพิ่มเติม เช่น "แก้ไขปัญหาที่ปรากฏ" กลไกนี้รับรองการกำกับดูแลของมนุษย์ ณ จุดตัดสินใจที่สำคัญ ป้องกันไม่ให้ AI ทำงานผิดพลาด อย่างไรก็ตาม มันก็หมายความว่า Agent ของ Cursor ขาดความเป็นอิสระในการวางแผนแบบลูกโซ่ยาว โดยต้องอาศัยคำแนะนำจากมนุษย์ทีละขั้นตอนเพื่อทำงานแบบวงปิดที่ซับซ้อนให้สำเร็จ เพื่อปรับปรุงความเป็นอิสระอย่างต่อเนื่องบางส่วน ทีม Cursor ยังได้เพิ่มคุณสมบัติการวนซ้ำบางอย่างให้กับระบบ Agent ตัวอย่างเช่น มันจะพยายามคอมไพล์และรันโค้ดและตรวจจับข้อผิดพลาด, แก้ไขปัญหาพื้นฐานบางอย่างโดยอัตโนมัติ เช่น ข้อผิดพลาดทางไวยากรณ์หรือ lint แต่โดยปกติจะหยุดหลังจากพยายามไม่กี่ครั้ง โดยคืนการควบคุมให้ผู้ใช้ นักพัฒนาได้สังเกตเห็นว่า Agent ของ Cursor ทำงานได้อย่างมีประสิทธิภาพมากในการปรับโครงสร้างโค้ดในพื้นที่หรือการเปลี่ยนแปลงในขอบเขตจำกัด แต่สำหรับการเปลี่ยนแปลงในวงกว้าง มักจะต้องให้ผู้ใช้ป้อนพรอมต์เป็นส่วนๆ เพื่อทำงานให้สำเร็จทีละขั้นตอน โดยรวมแล้ว Cursor วางตำแหน่ง Agent เป็น "ผู้ช่วยดำเนินการอัจฉริยะ" แทนที่จะเป็นหุ่นยนต์เขียนโปรแกรมอัตโนมัติที่ทรงพลังทุกอย่าง; การวางแผนงานของมันมุ่งเน้นไปที่การดำเนินการระยะสั้น การรายงานผลทันเวลา และการให้มนุษย์ตัดสินใจขั้นตอนต่อไป

**กลยุทธ์การเรียกใช้โมเดล:** Cursor ไม่ได้ฝึกอบรมโมเดลภาษาขนาดใหญ่ของตัวเอง; มันใช้กลยุทธ์การรวม API ของบุคคลที่สาม ผู้ใช้สามารถกำหนดค่าคีย์ API จากผู้ให้บริการเช่น OpenAI หรือ Anthropic ภายใน Cursor จากนั้นแบ็กเอนด์ของ Cursor จะเรียกใช้โมเดลขนาดใหญ่ที่เกี่ยวข้องในนามของผู้ใช้ ไม่ว่าผู้ใช้จะเลือกผู้ให้บริการโมเดลรายใด คำขอ AI ทั้งหมดจะผ่านเซิร์ฟเวอร์ของ Cursor เอง: แอปพลิเคชันในเครื่องจะรวมบริบทของโปรแกรมแก้ไขและคำถามของผู้ใช้ แล้วส่งไปยังคลาวด์, เซิร์ฟเวอร์ของ Cursor จะรวบรวมพรอมต์ที่สมบูรณ์และเรียกใช้โมเดล, จากนั้นส่งคืนผลลัพธ์ไปยังโปรแกรมแก้ไข สถาปัตยกรรมนี้อำนวยความสะดวกในการเพิ่มประสิทธิภาพพรอมต์ของ Cursor และการจัดการสถานะเซสชันแบบรวมศูนย์ แต่ก็หมายความว่าต้องใช้งานออนไลน์ และฟังก์ชัน AI หลักไม่สามารถใช้งานได้ในโหมดออฟไลน์ สำหรับการพิจารณาต้นทุนของนักพัฒนา Cursor รองรับผู้ใช้ที่ใช้โควตา API ของตนเอง (ดังนั้นการเรียกใช้โมเดลจะถูกเรียกเก็บเงินจากผู้ใช้) แต่ถึงกระนั้น คำขอยังคงผ่านเซิร์ฟเวอร์ทางการสำหรับการดำเนินการต่างๆ เช่น การดึงข้อมูลโค้ดฝังตัวและการจัดรูปแบบการตอบกลับ ในแง่ของการเลือกโมเดล Cursor โดยทั่วไปมีโมเดลกระแสหลักให้เลือกไม่กี่แบบ (เช่น GPT-4, GPT-3.5, Claude 2 เป็นต้น); ผู้ใช้สามารถเลือกโมเดลที่ต้องการได้ แต่ไม่สามารถเข้าถึงโมเดลที่ไม่รองรับโดย Cursor ในทางตรงกันข้าม ระบบอย่าง Windsurf อนุญาตให้เปลี่ยนเอ็นจิ้นพื้นฐานได้ ในขณะที่ Cursor มีความปิดมากกว่า โดยการอัปเดตและการปรับเปลี่ยนโมเดลส่วนใหญ่ควบคุมโดยทีมงานทางการ นอกจากนี้ Cursor ไม่มีโซลูชันการปรับใช้ในเครื่องเหมือน Copilot Enterprise และไม่ได้รวมโมเดลโอเพนซอร์ส—เป็นบริการคลาวด์โดยสมบูรณ์ ดังนั้นจึงสามารถติดตามเวอร์ชันโมเดลขนาดใหญ่ล่าสุดได้อย่างรวดเร็ว แต่ก็กำหนดให้ผู้ใช้ต้องเชื่อถือการประมวลผลบนคลาวด์และปฏิบัติตามนโยบายความเป็นส่วนตัวที่เกี่ยวข้อง เป็นที่น่าสังเกตว่า Cursor มี "โหมดการคิด" (Thinking mode); ตามความคิดเห็นของผู้ใช้ การเปิดใช้งานทำให้การตอบสนองของ AI ลึกซึ้งและเข้มงวดมากขึ้น ซึ่งอาจหมายถึงการเปลี่ยนไปใช้โมเดลที่ทรงพลังกว่าหรือการตั้งค่าพรอมต์พิเศษ แต่รายละเอียดการใช้งานเฉพาะเจาะจงไม่ได้รับการอธิบายโดยทีมงานทางการ

**การจัดการสถานะและการคงบริบท:** เพื่อเพิ่มความเข้าใจในโปรเจกต์ทั้งหมด Cursor จะประมวลผลโค้ดเบสล่วงหน้าในเครื่องหรือบนคลาวด์: โดยจะคำนวณเวกเตอร์ฝังตัวสำหรับไฟล์ทั้งหมดและสร้างดัชนีเชิงความหมายเพื่อรองรับการค้นหาเชิงความหมายและการจับคู่ความเกี่ยวข้อง โดยค่าเริ่มต้น เมื่อเปิดโปรเจกต์ใหม่ Cursor จะอัปโหลดส่วนของโค้ดเป็นชุดไปยังเซิร์ฟเวอร์คลาวด์โดยอัตโนมัติเพื่อสร้าง embeddings และบันทึก (จัดเก็บเฉพาะเวกเตอร์ฝังตัวและแฮชไฟล์ ไม่ใช่โค้ดข้อความธรรมดา) ด้วยวิธีนี้ เมื่อผู้ใช้ถามคำถามเกี่ยวกับโค้ด Cursor สามารถค้นหาไฟล์หรือส่วนของโค้ดที่เกี่ยวข้องในพื้นที่ embedding และดึงเนื้อหาเพื่อส่งให้โมเดลอ้างอิง โดยไม่ต้องป้อนโค้ดเบสทั้งหมดลงในพรอมต์ อย่างไรก็ตาม เนื่องจากหน้าต่างบริบทของโมเดลมีจำกัด (หลายพันถึงหลายหมื่นโทเค็น) กลยุทธ์ของ Cursor คือการมุ่งเน้นไปที่บริบทปัจจุบัน: นั่นคือ ส่วนใหญ่ให้โมเดลเน้นไปที่ไฟล์ที่ผู้ใช้กำลังแก้ไขอยู่, ส่วนของโค้ดที่เลือก, หรือส่วนของโค้ดที่ผู้ใช้ให้มา Cursor มีจุดเข้าใช้งาน "Knows your codebase" ที่อนุญาตให้คุณถามเกี่ยวกับเนื้อหาของไฟล์ที่ยังไม่ได้เปิด; โดยพื้นฐานแล้วจะทำการค้นหาเชิงความหมายในเบื้องหลังและแทรกเนื้อหาที่เกี่ยวข้องที่พบลงในพรอมต์ กล่าวอีกนัยหนึ่ง หากคุณต้องการให้ AI พิจารณาโค้ดบางส่วน คุณมักจะต้องเปิดไฟล์นั้นหรือวางลงในการสนทนา; มิฉะนั้น Cursor จะไม่ป้อนเนื้อหาไฟล์ "ที่ไม่เกี่ยวข้อง" มากเกินไปให้กับโมเดลโดยค่าเริ่มต้น การจัดการบริบทนี้ช่วยให้มั่นใจว่าคำตอบมีความแม่นยำ แต่ก็อาจพลาดการเชื่อมโยงข้ามไฟล์โดยนัยในโปรเจกต์ เว้นแต่ผู้ใช้จะตระหนักและแจ้งให้ AI ดึงข้อมูลเหล่านั้น เพื่อแก้ไขปัญหาหน่วยความจำระยะยาว Cursor มีกลไก Project Rules นักพัฒนาสามารถสร้างไฟล์ `.cursor/rules/*.mdc` เพื่อบันทึกความรู้สำคัญของโปรเจกต์ มาตรฐานการเขียนโค้ด หรือแม้แต่คำแนะนำเฉพาะ และ Cursor จะโหลดกฎเหล่านี้โดยอัตโนมัติเป็นส่วนหนึ่งของพรอมต์ระบบเมื่อแต่ละเซสชันเริ่มต้น ตัวอย่างเช่น คุณสามารถกำหนดกฎเช่น "ฟังก์ชัน API ทั้งหมดควรมีการบันทึก" และ Cursor จะปฏิบัติตามข้อตกลงนี้เมื่อสร้างโค้ด—ผู้ใช้บางรายรายงานว่าด้วยการสะสมประสบการณ์โปรเจกต์อย่างต่อเนื่องในไฟล์กฎ ความเข้าใจและความสอดคล้องของ Cursor กับโปรเจกต์ดีขึ้นอย่างมาก ไฟล์กฎเหล่านี้เทียบเท่ากับหน่วยความจำระยะยาวที่นักพัฒนาให้แก่ Agent ซึ่งบำรุงรักษาและอัปเดตโดยมนุษย์ (สามารถขอให้ Cursor "เพิ่มข้อสรุปของการสนทนานี้ลงในกฎ" ได้) นอกจากนี้ Cursor

### Windsurf (Codeium) Agent Architecture

**ปรัชญาการออกแบบสถาปัตยกรรม:** Windsurf เป็นผลิตภัณฑ์การเขียนโปรแกรมที่ขับเคลื่อนด้วย AI ซึ่งเปิดตัวโดยทีม Codeium โดยวางตำแหน่งให้เป็น "Agentic IDE" (สภาพแวดล้อมการพัฒนาแบบบูรณาการที่ขับเคลื่อนด้วย Agent อัจฉริยะ) แห่งแรกของอุตสาหกรรม ไม่เหมือน Copilot ที่ต้องสลับระหว่างโหมด Chat/Agent ผู้ช่วย AI ของ Windsurf (ชื่อ Cascade) มีความสามารถแบบ Agent ตลอดเวลา โดยสลับเปลี่ยนได้อย่างราบรื่นระหว่างการตอบคำถามและการดำเนินการหลายขั้นตอนด้วยตนเองตามความจำเป็น Codeium สรุปปรัชญาของตนอย่างเป็นทางการว่า "Flows = Agents + Copilots" Flow หมายถึงนักพัฒนาและ AI ที่อยู่ในสถานะการทำงานร่วมกันแบบซิงโครนัส: AI ให้คำแนะนำเหมือนผู้ช่วยได้ตลอดเวลา และยังสามารถเข้าควบคุมและดำเนินการชุดการทำงานต่างๆ ได้อย่างกระตือรือร้นเมื่อจำเป็น ในขณะที่กระบวนการทั้งหมดจะซิงโครไนซ์แบบเรียลไทม์กับการดำเนินการของนักพัฒนา สถาปัตยกรรมนี้ไม่มีจุดสลับบทบาทระหว่างมนุษย์กับเครื่องจักรที่ชัดเจน; AI จะ "รับรู้" การกระทำของนักพัฒนาอย่างต่อเนื่องและปรับให้เข้ากับจังหวะ เมื่อคุณสนทนากับ Cascade ใน Windsurf มันสามารถตอบคำถามของคุณได้โดยตรง หรือตีความคำพูดของคุณว่าเป็นงาน จากนั้นจึงเรียกใช้ชุดการดำเนินการต่างๆ ตัวอย่างเช่น หากผู้ใช้เพียงแค่บอก Cascade ในการสนทนาว่า "โปรดใช้การยืนยันตัวตนผู้ใช้และอัปเดตส่วนโค้ดที่เกี่ยวข้อง" Cascade สามารถเข้าใจโดยอัตโนมัติว่านี่เป็นข้อกำหนดที่เกี่ยวข้องกับหลายโมดูล: มันจะค้นหาฐานโค้ดเพื่อระบุไฟล์ที่เกี่ยวข้องกับการยืนยันตัวตนผู้

### สรุปการเปรียบเทียบระบบ

ด้านล่างนี้คือตารางสรุปภาพรวมความคล้ายคลึงและความแตกต่างของสถาปัตยกรรม Agent ใน GitHub Copilot, Cursor และ Windsurf:

| มิติคุณสมบัติ                | GitHub Copilot                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Cursor                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Windsurf (Codeium)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| ---------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **ตำแหน่งทางสถาปัตยกรรม**    | เริ่มต้นจากการเป็นแชทบอทสำหรับช่วยเขียนโปรแกรม ขยายไปสู่ "โหมด Agent" (ชื่อรหัส Project Padawan); Agent สามารถฝังอยู่ในแพลตฟอร์ม GitHub, ผสานรวมกับการทำงานของ Issues/PRs. การสนทนาแบบหลายรอบใน Agent เดียว, ไม่มีสถาปัตยกรรมแบบหลาย Agent ที่ชัดเจน. รองรับอินพุตหลายรูปแบบ (รูปภาพ).                                                                                                                                                                                      | เอดิเตอร์แบบ AI-first ที่ทำงานแบบโลคอล (พัฒนาต่อยอดจาก VS Code), มีโหมด Chat และโหมด Agent. โหมดผู้ช่วยเริ่มต้นเน้นการถาม-ตอบและการเติมโค้ด, โหมด Agent ต้องเปิดใช้งานอย่างชัดเจนเพื่อให้ AI ดำเนินการงานได้ด้วยตนเอง. สถาปัตยกรรม Agent เดียว, ไม่มีการประมวลผลหลายรูปแบบ.                                                                                                                                                                                                                                                      | ออกแบบมาตั้งแต่ต้นให้เป็น "Agentic IDE": ผู้ช่วย AI Cascade ออนไลน์ตลอดเวลา, สามารถทั้งแชทและดำเนินการหลายขั้นตอนได้ด้วยตนเอง, ไม่ต้องสลับโหมด. การทำงานแบบ Agent เดียว, บรรลุการทำงานร่วมกันแบบซิงโครนัสระหว่างมนุษย์และ AI ผ่าน Flows, ปัจจุบันเน้นที่ข้อความโค้ด.                                                                                                                                                                                                                                                                                                                                                                       |
| **การวางแผนและดำเนินการงาน** | รองรับการแบ่งงานอัตโนมัติและการดำเนินการซ้ำ. Agent จะแบ่งคำขอของผู้ใช้เป็นงานย่อยและดำเนินการซ้ำจนกว่าจะบรรลุเป้าหมายหรือถูกหยุดอย่างชัดเจน. มีความสามารถในการแก้ไขตัวเอง (สามารถระบุและแก้ไขข้อผิดพลาดในการคอมไพล์/ทดสอบได้). ส่งมอบผลลัพธ์เป็น PRs หลังจากการทำงานแต่ละครั้งเสร็จสิ้นและรอการตรวจสอบจากมนุษย์; ข้อเสนอแนะจากการตรวจสอบจะกระตุ้นการทำซ้ำครั้งถัดไป.                                                                                                        | สามารถจัดการการแก้ไขข้ามไฟล์ได้ แต่มีแนวโน้มไปทางการดำเนินการแบบครั้งเดียว: Agent จะได้รับคำสั่งและให้ข้อเสนอแนะการแก้ไขทั้งหมดในคราวเดียว, แสดงรายการ diffs เพื่อให้ผู้ใช้อนุมัติ. โดยปกติจะไม่ทำซ้ำหลายรอบด้วยตนเอง (เว้นแต่ผู้ใช้จะแจ้งอีกครั้ง), และข้อผิดพลาดมักจะถูกปล่อยให้ผู้ใช้ตัดสินใจว่าจะให้ AI แก้ไขหรือไม่. ทำการแก้ไขอัตโนมัติเพียงจำนวนจำกัดโดยค่าเริ่มต้น, เพื่อหลีกเลี่ยงการค้างที่ไม่สิ้นสุด.                                                                                                                 | ความเป็นอิสระเชิงลึก: Cascade สามารถแบ่งความต้องการระดับสูงออกเป็นชุดของการกระทำและดำเนินการอย่างต่อเนื่องจนกว่างานจะเสร็จสมบูรณ์. โดดเด่นในการ refactoring ขนาดใหญ่และงานข้ามโมดูล, เชื่อมโยงการเรียกใช้การแก้ไข, การสร้างไฟล์, การรันคำสั่ง, การตรวจสอบการทดสอบ ฯลฯ โดยอัตโนมัติ, จนกว่าโค้ดจะผ่านการตรวจสอบด้วยตนเอง. หากพบปัญหาใหม่ในระหว่างกระบวนการ, มันจะดำเนินการซ้ำและแก้ไขต่อไป, แทบไม่ต้องมีการแทรกแซงจากมนุษย์ยกเว้นผลลัพธ์สุดท้าย (แต่การเปลี่ยนแปลงที่สำคัญจะต้องได้รับการยืนยันขั้นสุดท้ายจากมนุษย์).                                                                                                                       |
| **กลยุทธ์โมเดล**             | การรวมหลายโมเดลบนคลาวด์: รองรับ OpenAI GPT-4, GPT-3.5 series (ชื่อรหัสภายใน o1, o3-mini, ฯลฯ), Anthropic Claude 3.5, Google Gemini 2.0, ฯลฯ, และผู้ใช้สามารถสลับโมเดลที่ต้องการได้ในอินเทอร์เฟซ. ปรับปรุงประสิทธิภาพผ่านสถาปัตยกรรมแบบสองโมเดล (โมเดลขนาดใหญ่สร้างโซลูชัน, โมเดลขนาดเล็กนำการเปลี่ยนแปลงไปใช้ได้อย่างรวดเร็ว). โมเดลทั้งหมดถูกโฮสต์และเรียกใช้โดย GitHub; คำขอของผู้ใช้ Copilot Enterprise จะผ่านอินสแตนซ์เฉพาะ. ไม่รองรับการติดตั้งแบบ private deployment. | พึ่งพา API โมเดลขนาดใหญ่จากภายนอกโดยสมบูรณ์: คำขอทั้งหมดจะถูกส่งผ่านคลาวด์ของ Cursor และเรียกใช้โมเดล OpenAI/Anthropic. ผู้ใช้สามารถใช้ API Key ของตนเองได้ (จัดการการเรียกเก็บเงินด้วยตนเอง) แต่การเรียกใช้ยังคงเกิดขึ้นบนเซิร์ฟเวอร์ทางการ. ไม่มีตัวเลือกโมเดลแบบออฟไลน์หรือโลคอล. ประเภทโมเดลขึ้นอยู่กับช่วงที่ Cursor รองรับ; ผู้ใช้ไม่สามารถรวมโมเดลใหม่ได้อย่างอิสระ. Cursor ไม่ได้ฝึกโมเดลโดยตรง แต่ปรับโมเดลภายนอกโดยการปรับปรุง prompts.                                                                                | โมเดลที่พัฒนาเองเป็นหลัก, แบ็กเอนด์ที่ยืดหยุ่น: ใช้โมเดลโค้ดที่เป็นกรรมสิทธิ์ของ Codeium โดยค่าเริ่มต้น, และอนุญาตให้ผู้ใช้ระดับองค์กรเลือกการติดตั้งแบบ self-hosted. สถาปัตยกรรมรองรับการเปลี่ยนเอ็นจิ้นโมเดลที่แตกต่างกัน (โมเดล "Sonnet" ของ Codeium หรือโอเพนซอร์ส, ฯลฯ), และสามารถขยายอินเทอร์เฟซของบุคคลที่สามได้ในอนาคต. ฟังก์ชันน้ำหนักเบาบางอย่างใช้โมเดลขนาดเล็กสำหรับการประมวลผลแบบโลคอล/เอดจ์เพื่อลดความหน่วง. เน้นการควบคุมสภาพแวดล้อม AI ของผู้ใช้ (ความเร็วในการอัปเดตโมเดล, ความเสถียรของเวอร์ชันที่ผู้ใช้ควบคุม).                                                                                                         |
| **บริบทและหน่วยความจำ**      | ใช้กลยุทธ์ RAG เพื่อดึงบริบทโค้ด: ดึงส่วนย่อยของโค้ดที่เกี่ยวข้องผ่าน GitHub Code Search และแทรกเข้าไปใน prompts. Prompts จะรวมสรุปโครงสร้างโปรเจกต์แทนที่จะเป็นข้อความเต็มเพื่อประหยัดโทเค็น. รองรับการรวมคำอธิบาย Issue, การสนทนา PR ที่เกี่ยวข้องเข้ากับบริบทเพื่อทำความเข้าใจเจตนาของงานและมาตรฐานโปรเจกต์. ประวัติการสนทนาจะถูกเก็บไว้ภายในเซสชันเดียว; ไม่มีหน่วยความจำข้ามเซสชันอัตโนมัติ (ต้องอาศัย Issues/PRs หรือ READMEs เพื่อส่งข้อมูลข้ามเซสชัน).              | สร้างดัชนีเวกเตอร์สำหรับโปรเจกต์เมื่อเริ่มต้นเพื่อรองรับการค้นหาเชิงความหมาย. Prompts ของโมเดลจะเน้นที่บริบทโค้ดที่ผู้ใช้ให้มาในปัจจุบัน (ไฟล์ที่เปิดอยู่หรือส่วนย่อย); เมื่อต้องการส่วนอื่น ๆ, จะถูกดึงผ่านความเกี่ยวข้องเชิงความหมายและแทรกเข้าไป. มีกลไกไฟล์ .cursor/rules, ช่วยให้นักพัฒนาสามารถกำหนดความรู้และมาตรฐานถาวรสำหรับโปรเจกต์; Agent จะอ่านกฎเหล่านี้ในการสนทนาแต่ละครั้ง, เทียบเท่ากับหน่วยความจำระยะยาวที่มนุษย์ให้มา. ไม่มีหน่วยความจำข้ามเซสชันอัตโนมัติโดยค่าเริ่มต้น (ผู้ใช้ต้องบันทึกด้วยตนเองลงในไฟล์กฎ). | การจัดทำดัชนีเชิงความหมายของโปรเจกต์ทั้งหมด: สแกนโค้ดเบสทั้งหมดล่วงหน้าในเครื่องเพื่อสร้างดัชนี; Cascade สามารถดึงเนื้อหาไฟล์ใดก็ได้เป็นบริบทได้ตลอดเวลา. มีระบบ Memories ที่บันทึกเนื้อหาการสนทนาที่สำคัญและบันทึก/กฎที่ผู้ใช้ระบุโดยอัตโนมัติและถาวร, ทำให้มีหน่วยความจำข้ามเซสชัน. ดังนั้น, Cascade จะ "จำ" ข้อตกลงของโปรเจกต์และการสนทนาก่อนหน้าได้แม้หลังจากรีสตาร์ท. นอกจากนี้ยังรวมสถานะสภาพแวดล้อม IDE เป็นแหล่งบริบท: การรับรู้แบบเรียลไทม์ของไฟล์ที่ผู้ใช้เปิด, ตำแหน่งเคอร์เซอร์, เอาต์พุตเทอร์มินัล ฯลฯ, โดยใช้ข้อมูลโดยนัยนี้เพื่อทำความเข้าใจเจตนาของผู้ใช้. โดยรวมแล้ว, Cascade มีมุมมองบริบทที่กว้างขวางและไดนามิกมากขึ้น. |
| **เครื่องมือและส่วนขยาย**    | การผสานรวมอย่างลึกซึ้งกับเวิร์กโฟลว์ของ GitHub: Agent ได้รับสภาพแวดล้อมการพัฒนาที่แยกต่างหากในคลาวด์ผ่าน GitHub Actions, สามารถรัน unit tests, รันโปรเจกต์ ฯลฯ. เครื่องมือในตัวประกอบ                                                                                                                                                                                                                                                                                       |
