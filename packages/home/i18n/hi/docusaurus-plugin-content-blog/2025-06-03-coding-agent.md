---
title: "गिटहब कोपायलट, कर्सर और विंडसर्फ की एजेंट सिस्टम आर्किटेक्चर"
tags: [एआई, प्रोग्रामिंग सहायक, गिटहब कोपायलट, कर्सर, विंडसर्फ, एजेंट सिस्टम]
keywords:
  [
    एआई आर्किटेक्चर,
    गिटहब कोपायलट,
    कर्सर,
    विंडसर्फ,
    प्रोग्रामिंग सहायक,
    एजेंट सिस्टम,
    कार्य विघटन,
    मॉडल आह्वान,
    संदर्भ प्रबंधन,
  ]
authors: [lark]
description: गिटहब कोपायलट, कर्सर और विंडसर्फ के एजेंट सिस्टम आर्किटेक्चर का गहन विश्लेषण, जो एआई-संचालित प्रोग्रामिंग सहायता पर उनके प्रभाव को समझने के लिए उनकी डिज़ाइन फिलॉसफी, कार्य विघटन, मॉडल आह्वान रणनीतियों और संदर्भ प्रबंधन पर केंद्रित है।
image: "https://opengraph-image.blockeden.xyz/api/og-cuckoo-network?title=गिटहब%20कोपायलट%2C%20कर्सर%20और%20विंडसर्फ%20की%20एजेंट%20सिस्टम%20आर्किटेक्चर"
---

## GitHub Copilot, Cursor, और Windsurf के एजेंट सिस्टम आर्किटेक्चर

हाल के वर्षों में, GitHub Copilot, Cursor, और Windsurf जैसे कई AI प्रोग्रामिंग सहायक उत्पाद सामने आए हैं। उनके सभी कार्यान्वयन "एजेंट" (बुद्धिमान एजेंट) की अवधारणा पेश करते हैं, जिससे AI को कोडिंग कार्य में अधिक सक्रिय रूप से सहायता करने की अनुमति मिलती है। यह लेख इंजीनियरिंग आर्किटेक्चर के दृष्टिकोण से इन उत्पादों के एजेंट सिस्टम निर्माण का गहन सर्वेक्षण प्रदान करता है, जिसमें आर्किटेक्चरल डिज़ाइन फिलॉसफी, कार्य विघटन और योजना, मॉडल आह्वान रणनीतियाँ, संदर्भ स्थिति प्रबंधन, प्लगइन विस्तार तंत्र, और उनके संबंधित डिज़ाइनों में प्रमुख ट्रेड-ऑफ और नवाचार शामिल हैं। निम्नलिखित सामग्री मुख्य रूप से आधिकारिक इंजीनियरिंग ब्लॉगों, परियोजना डेवलपर्स के लेखों और संबंधित तकनीकी सामग्रियों पर आधारित है।

![](https://opengraph-image.blockeden.xyz/api/og-cuckoo-network?title=GitHub%20Copilot%2C%20Cursor%2C%20%E0%A4%94%E0%A4%B0%20Windsurf%20%E0%A4%95%E0%A5%87%20%E0%A4%8F%E0%A4%9C%E0%A5%87%E0%A4%82%E0%A4%9F%20%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE%20%E0%A4%86%E0%A4%B0%E0%A5%8D%E0%A4%95%E0%A4%BF%E0%A4%9F%E0%A5%87%E0%A4%95%E0%A5%8D%E0%A4%9A%E0%A4%B0)

### गिटहब कोपायलट की एजेंट वास्तुकला

**वास्तुशिल्प डिज़ाइन दर्शन:** गिटहब कोपायलट ने शुरू में खुद को एक डेवलपर के "एआई पेयर प्रोग्रामर" के रूप में स्थापित किया था, और अब इसे "एजेंट" मोड के साथ विस्तारित किया है। इसका एजेंट सिस्टम स्वतंत्र एजेंटों का संग्रह नहीं है, बल्कि एक एम्बेडेड बुद्धिमान एजेंट है जो बहु-मोड़ वाली बातचीत और बहु-चरणीय कार्य निष्पादन में संलग्न हो सकता है, जो बहु-मोडल इनपुट का समर्थन करता है (उदाहरण के लिए, स्क्रीनशॉट की व्याख्या करने के लिए विजन मॉडल का उपयोग करना)। कोपायलट डेवलपर्स के प्रतिस्थापन के बजाय एआई सहायता पर जोर देता है। एजेंट मोड में, यह एक टीम के भीतर एक स्वचालित इंजीनियर की तरह अधिक कार्य करता है, सौंपे गए कार्यों को स्वीकार करता है, स्वायत्त रूप से कोड लिखता है, डीबग करता है, और पुल रिक्वेस्ट के माध्यम से परिणाम सबमिट करता है। इस एजेंट को चैट इंटरफ़ेस के माध्यम से या कोपायलट को एक गिटहब इश्यू असाइन करके ट्रिगर किया जा सकता है।

**कार्य का विघटन और योजना:** कोपायलट का एजेंट जटिल सॉफ्टवेयर कार्यों को उप-कार्यों में तोड़ने और उन्हें एक-एक करके पूरा करने में उत्कृष्ट है, जो चेन-ऑफ-थॉट के समान एक आंतरिक तर्क प्रक्रिया को नियोजित करता है। यह उपयोगकर्ता की आवश्यकताओं को पूरा होने तक "समस्या का विश्लेषण करें → कोड परिवर्तन या कमांड निष्पादित करें → परिणामों को सत्यापित करें" के माध्यम से बार-बार चक्रित होता है। उदाहरण के लिए, एजेंट मोड में, कोपायलट न केवल उपयोगकर्ता-निर्दिष्ट चरणों को निष्पादित करता है, बल्कि मुख्य लक्ष्य को प्राप्त करने के लिए आवश्यक अतिरिक्त चरणों को _अप्रत्यक्ष रूप से_ अनुमानित और स्वचालित रूप से निष्पादित भी करता है। यदि प्रक्रिया के दौरान संकलन त्रुटियां या परीक्षण विफलताएं होती हैं, तो एजेंट स्वयं त्रुटियों की पहचान करता है और उन्हें ठीक करता है, और फिर से प्रयास करता है, ताकि डेवलपर्स को त्रुटि संदेशों को प्रॉम्प्ट के रूप में बार-बार कॉपी और पेस्ट न करना पड़े। एक वीएस कोड ब्लॉग इसके कार्य चक्र को सारांशित करता है: कोपायलट एजेंट स्वायत्त रूप से प्रासंगिक संदर्भ और संपादित किए जाने वाले फ़ाइलों को निर्धारित करता है, चलाने के लिए कोड संशोधनों और कमांड का प्रस्ताव करता है, संपादन या टर्मिनल आउटपुट की शुद्धता की निगरानी करता है, और कार्य पूरा होने तक लगातार पुनरावृति करता है। यह स्वचालित बहु-मोड़ निष्पादन कोपायलट को विभिन्न प्रकार के कार्यों को संभालने की अनुमति देता है, एक साधारण एप्लिकेशन बनाने से लेकर कई फ़ाइलों में बड़े पैमाने पर रिफैक्टरिंग तक।

**मॉडल आह्वान रणनीति:** गिटहब कोपायलट के पीछे के मॉडल शुरू में ओपनएआई के कोडक्स थे, जिन्हें अब एक अधिक शक्तिशाली बहु-मॉडल वास्तुकला में अपग्रेड किया गया है। कोपायलट उपयोगकर्ताओं को "मॉडल विकल्प" में विभिन्न आधार मॉडल चुनने की अनुमति देता है, जैसे कि ओपनएआई का जीपीटी-4 (आंतरिक कोडनेम जीपीटी-4ओ) और इसका सरलीकृत संस्करण, एंथ्रोपिक का क्लाउड 3.5 (कोडनेम सोनेट), और गूगल का नवीनतम जेमिनी 2.0 फ्लैश, अन्य के साथ। यह बहु-मॉडल समर्थन का अर्थ है कि कोपायलट कार्य आवश्यकताओं या उपयोगकर्ता प्राथमिकताओं के आधार पर मॉडल स्रोतों को स्विच कर सकता है। कोपायलट एडिट्स (बहु-फ़ाइल संपादन) कार्यक्षमता में, गिटहब दक्षता में सुधार के लिए एक दोहरी-मॉडल वास्तुकला का भी उपयोग करता है: सबसे पहले, चयनित "बड़ा मॉडल" पूर्ण संदर्भ के साथ एक प्रारंभिक संपादन योजना उत्पन्न करता है, फिर एक विशेष "सट्टा डिकोडिंग" एंडपॉइंट इन परिवर्तनों को तुरंत लागू करता है। सट्टा डिकोडर को एक हल्के मॉडल या नियम इंजन के रूप में देखा जा सकता है जो संपादन परिणामों को पूर्व-उत्पन्न करता है जबकि बड़ा मॉडल कोड परिवर्तनों पर विचार करता है, जिससे विलंबता कम होती है। संक्षेप में, कोपायलट की मॉडल रणनीति क्लाउड में कई अत्याधुनिक एलएलएम को एकीकृत करना है, जो विभिन्न परिदृश्यों के लिए अनुकूलित हैं, और इंजीनियरिंग साधनों (दोहरी-मॉडल पाइपलाइन) के माध्यम से प्रतिक्रिया गति और सटीकता को संतुलित करना है।

**स्टेट प्रबंधन और संदर्भ प्रतिधारण:** कोपायलट एजेंट विकास संदर्भ का लाभ उठाने पर बहुत जोर देता है। चूंकि पूरे रिपॉजिटरी कोड को सीधे बड़े मॉडलों को इनपुट के रूप में प्रदान करना अव्यावहारिक है, कोपायलट एक **पुनर्प्राप्ति-संवर्धित पीढ़ी (RAG)** रणनीति का उपयोग करता है: यह गिटहब कोड सर्च जैसे टूल का उपयोग करके रिपॉजिटरी के भीतर प्रासंगिक सामग्री खोजता है और पुनर्प्राप्त कोड स्निपेट्स को मॉडल के संदर्भ में गतिशील रूप से इंजेक्ट करता है। जब एजेंट शुरू होता है, तो यह प्रोजेक्ट कोड को एक अलग वातावरण में क्लोन करता है और पहले कोडबेस संरचना का विश्लेषण करता है, टोकन बचाने के लिए आवश्यक सारांश उत्पन्न करता है। उदाहरण के लिए, कोपायलट द्वारा निर्मित एक प्रॉम्प्ट में "प्रोजेक्ट फ़ाइल संरचना सारांश + मुख्य फ़ाइल सामग्री + उपयोगकर्ता अनुरोध" शामिल हो सकता है। यह मॉडल को संदर्भ लंबाई की सीमाओं को पार किए बिना समाधान उत्पन्न करते समय समग्र तस्वीर को समझने की अनुमति देता है। बातचीत के दौरान, कोपायलट निरंतरता बनाए रखने के लिए सत्र इतिहास (उदाहरण के लिए, चैट में उपयोगकर्ता द्वारा पहले दिए गए निर्देश) को भी ट्रैक करता है। साथ ही, कोपायलट गिटहब प्लेटफॉर्म के साथ गहराई से एकीकृत है, जिससे यह इश्यू विवरण, संबंधित पीआर चर्चाओं आदि को अतिरिक्त संदर्भ के रूप में उपयोग कर सकता है। विशेष रूप से, यदि रिपॉजिटरी में कोडिंग मानकों या एआई उपयोग के लिए पूर्व निर्देशों को निर्दिष्ट करने वाली कॉन्फ़िगरेशन फ़ाइलें हैं, तो एजेंट इन कस्टम रिपॉजिटरी निर्देशों का भी पालन करेगा। यह ध्यान रखना महत्वपूर्ण है कि कोपायलट के पास उपयोगकर्ता कोड की दीर्घकालिक स्मृति नहीं है—यह अगले सत्र के लिए प्रत्येक सत्र से परे स्वचालित रूप से स्थिति को सहेजता नहीं है (जब तक कि उपयोगकर्ता द्वारा दस्तावेज़ीकरण में हार्डकोड न किया गया हो)। हालांकि, गिटहब के इश्यू/पीआर वाहनों के माध्यम से, उपयोगकर्ता एजेंट को प्रभावी ढंग से लगातार कार्य विवरण और स्क्रीनशॉट प्रदान कर सकते हैं, जिसे संदर्भ ले जाने के साधन के रूप में देखा जा सकता है।

**प्लगइन सिस्टम और विस्तार तंत्र:** गिटहब कोपायलट एजेंट टूल कॉल (टूल उपयोग) के माध्यम से आईडीई और बाहरी वातावरण पर संचालन करता है। एक ओर, स्थानीय या कोडस्पेस वातावरण में, कोपायलट फ़ाइलों को पढ़ने, संपादकों को खोलने, कोड स्निपेट्स डालने और टर्मिनल कमांड चलाने जैसे संचालन करने के लिए वीएस कोड एक्सटेंशन द्वारा प्रदान किए गए एपीआई को इनवोक कर सकता है। दूसरी ओर, गिटहब ने एजेंट की "दृष्टि" और क्षमताओं का विस्तार करने के लिए **मॉडल संदर्भ प्रोटोकॉल (MCP)** पेश किया है। एमसीपी बाहरी "संसाधन सर्वर" को कॉन्फ़िगर करने की अनुमति देता है, और एजेंट एक मानकीकृत इंटरफ़ेस के माध्यम से अतिरिक्त डेटा या संचालन का अनुरोध कर सकता है। उदाहरण के लिए, गिटहब आधिकारिक तौर पर अपना स्वयं का एमसीपी सर्वर प्रदान करता है, जिससे एजेंट को वर्तमान रिपॉजिटरी के बारे में अधिक जानकारी प्राप्त करने की अनुमति मिलती है (जैसे कोड खोज परिणाम, प्रोजेक्ट विकी, आदि)। एमसीपी तंत्र तीसरे पक्ष का भी समर्थन करता है: जब तक वे एमसीपी इंटरफ़ेस को लागू करते हैं, एजेंट कनेक्ट हो सकता है, जैसे डेटाबेस क्वेरी सेवाओं को कॉल करना या एचटीटीपी अनुरोध भेजना। कोपायलट एजेंट के पास पहले से ही कुछ बहु-मोडल क्षमताएं हैं। विजन मॉडल के साथ एकीकृत करके, यह स्क्रीनशॉट, डिज़ाइन आरेख और उपयोगकर्ताओं द्वारा इश्यू में संलग्न अन्य छवियों को सहायक इनपुट के रूप में पार्स कर सकता है। इसका मतलब है कि यूआई मुद्दों को डीबग करते समय या त्रुटियों को पुन: उत्पन्न करते समय, डेवलपर्स कोपायलट को स्क्रीनशॉट प्रदान कर सकते हैं, और एजेंट संबंधित कोड संशोधन सुझावों की पेशकश करने के लिए "चित्रों से बात" कर सकता है। इसके अलावा, एक कार्य पूरा करने के बाद, कोपायलट एजेंट स्वचालित रूप से गिट के माध्यम से परिवर्तनों को कमिट करता है और एक ड्राफ्ट पीआर खोलता है, फिर समीक्षा का अनुरोध करने के लिए प्रासंगिक डेवलपर्स को **@मेंशन** करता है। समीक्षकों की टिप्पणियां और प्रतिक्रिया (उदाहरण के लिए, एक निश्चित कार्यान्वयन के संशोधन का अनुरोध करना) भी एजेंट द्वारा पढ़ी जाती हैं और नए निर्देशों के रूप में कार्य करती हैं, जिससे कोड अपडेट का अगला दौर शुरू होता है। पूरी प्रक्रिया मानव डेवलपर सहयोग से मिलती जुलती है: एआई एजेंट कोड सबमिट करता है → मानव समीक्षा करता है और प्रतिक्रिया प्रदान करता है → एआई एजेंट परिष्कृत करता है, यह सुनिश्चित करते हुए कि मनुष्यों का हमेशा नियंत्रण रहे।

**प्रमुख डिज़ाइन ट्रेड-ऑफ और नवाचार:** गिटहब कोपायलट का एजेंट सिस्टम मौजूदा गिटहब प्लेटफॉर्म इकोसिस्टम का पूरी तरह से लाभ उठाता है, जो इसकी महत्वपूर्ण विशेषता है। एक ओर, यह गिटहब एक्शन्स क्लाउड कंटेनरों पर कोड निष्पादन वातावरण स्थापित करना चुनता है, जिससे अच्छा अलगाव और स्केलेबिलिटी प्राप्त होती है। "प्रोजेक्ट पाडावन" इस वास्तुकला का कोडनेम है, जो खरोंच से एक नया निष्पादन बुनियादी ढांचा बनाने से बचता है और इसके बजाय एक परिपक्व सीआई/सीडी सिस्टम पर आधारित है। दूसरी ओर, कोपायलट सुरक्षा के संदर्भ में सख्त ट्रेड-ऑफ करता है: डिफ़ॉल्ट रूप से, एजेंट केवल नई बनाई गई शाखाओं में कोड को पुश कर सकता है, मुख्य शाखा को सीधे संशोधित नहीं कर सकता है, और ट्रिगर किए गए पीआर को मर्ज करने से पहले दूसरों द्वारा अनुमोदित किया जाना चाहिए, और अनुमोदन से पहले सीआई पाइपलाइन रोक दी जाती हैं। ये रणनीतियाँ सुनिश्चित करती हैं कि एआई स्वचालन की शुरुआत टीम के मौजूदा समीक्षा प्रणाली और रिलीज गेट्स को बाधित न करे। मॉडल संदर्भ प्रोटोकॉल का प्रस्ताव कोपायलट के लिए एक महत्वपूर्ण इंजीनियरिंग नवाचार के रूप में देखा जा सकता है—यह एलएलएम एजेंटों के लिए बाहरी टूल/डेटा तक पहुंचने के लिए एक खुला मानक परिभाषित करता है, जिससे गिटहब के भीतर और बाहर दोनों जगह विभिन्न डेटा स्रोतों को भविष्य में एआई प्रॉम्प्ट में सहजता से एकीकृत किया जा सके। इसके अतिरिक्त, कोपायलट एजेंट निष्पादन के दौरान विचार लॉग (सत्र लॉग) रिकॉर्ड करता है, जिसमें टूल को कॉल करने के लिए उठाए गए कदम और उसके द्वारा उत्पन्न आउटपुट शामिल हैं, और इन रिकॉर्ड्स को डेवलपर को प्रस्तुत करता है। यह पारदर्शिता उपयोगकर्ताओं को एजेंट के "विचारों" और कार्यों की समीक्षा करने की अनुमति देती है, जिससे डीबगिंग और विश्वास निर्माण में सुविधा होती है। कुल मिलाकर, गिटहब कोपायलट एआई एजेंटों को विकास जीवन चक्र के विभिन्न चरणों (कोडिंग -> पीआर सबमिट करना -> कोड समीक्षा) में एम्बेड करता है, और वास्तुशिल्प निर्णयों की एक श्रृंखला के माध्यम से, मौजूदा वर्कफ़्लो के साथ स्वचालन का सहज एकीकरण प्राप्त करता है।

### कर्सर की एजेंट आर्किटेक्चर

**आर्किटेक्चरल डिज़ाइन फिलॉसफी:** कर्सर स्टार्टअप एनीस्फेयर द्वारा विकसित एक AI-संचालित कोडिंग टूल है। यह मूल रूप से एक कोड एडिटर (VS कोड पर आधारित संशोधित) है जो एक AI असिस्टेंट के साथ गहराई से एकीकृत है। कर्सर दो मुख्य इंटरेक्शन मोड प्रदान करता है: चैट असिस्टेंट और ऑटोनॉमस एजेंट। नियमित बातचीत मोड में, यह एक पारंपरिक कोड असिस्टेंट के रूप में कार्य करता है, निर्देशों के आधार पर प्रश्नों का उत्तर देता है या कोड उत्पन्न करता है; जब एजेंट मोड (जिसे "कंपोजर" भी कहा जाता है) में स्विच किया जाता है, तो कर्सर डेवलपर की ओर से सक्रिय रूप से कई ऑपरेशंस निष्पादित कर सकता है। यह आर्किटेक्चर उपयोगकर्ताओं को आवश्यकतानुसार चुनने की स्वतंत्रता देता है: साधारण कार्यों को असिस्टेंट मोड में लाइन-बाय-लाइन पूछकर संभाला जा सकता है, जबकि जटिल या दोहराए जाने वाले कार्यों को एजेंट को बुलाकर बैच में संसाधित किया जा सकता है। कर्सर वर्तमान में मुख्य रूप से टेक्स्ट (कोड) डोमेन में सहायता करने पर ध्यान केंद्रित करता है, मल्टी-मोडल इनपुट/आउटपुट पर जोर नहीं देता है (हालांकि यह वॉयस इनपुट कार्यक्षमता प्रदान करता है, जो प्रॉम्प्ट के लिए भाषण को टेक्स्ट में परिवर्तित करता है)। कोपायलट के समान, कर्सर का एजेंट सिस्टम भी श्रृंखला में एक एकल बुद्धिमान एजेंट के रूप में संचालित होता है, न कि समानांतर में काम करने वाले कई एजेंटों के रूप में। हालांकि, इसकी विशिष्ट विशेषता मानव-AI सहयोग पर इसका जोर है: एजेंट मोड में, AI यथासंभव अधिक से अधिक कार्य करता है, लेकिन कुल मिलाकर अभी भी डेवलपर्स को किसी भी समय हस्तक्षेप करने और नियंत्रण लेने की अनुमति देता है, बजाय इसके कि यह लंबे समय तक पूरी तरह से अनियंत्रित चले।

**कार्य अपघटन और योजना:** कर्सर के एजेंट मोड में, AI जटिल क्रॉस-फाइल कार्यों को संभाल सकता है, लेकिन डिज़ाइन चरण-दर-चरण अनुरोध शैली की ओर झुकता है। उपयोगकर्ता से एक उच्च-स्तरीय निर्देश प्राप्त करने के बाद, एजेंट स्वायत्त रूप से प्रासंगिक कोड स्निपेट्स की खोज करता है, संपादन की आवश्यकता वाले फ़ाइलों को खोलता है, संशोधन योजनाएं उत्पन्न करता है, और प्रभाव को सत्यापित करने के लिए परीक्षण/बिल्ड कमांड भी चलाता है। हालांकि, कोपायलट या विंडसर्फ के एजेंटों के विपरीत, कर्सर का एजेंट आमतौर पर एक प्रारंभिक प्रस्ताव पूरा करने के बाद रुक जाता है, उपयोगकर्ता की समीक्षा और आगे के निर्देशों की प्रतीक्षा करता है। इसका मतलब है कि कर्सर का एजेंट आमतौर पर तब तक लगातार और बार-बार खुद को बेहतर नहीं बनाता जब तक कि उसे उपयोगकर्ता से एक नया प्रॉम्प्ट प्राप्त न हो। उदाहरण के लिए, यदि आप कर्सर को क्रॉस-प्रोजेक्ट रीफैक्टरिंग करने के लिए कहते हैं, तो यह उन सभी स्थानों को एकत्र करेगा जिन्हें संशोधन की आवश्यकता है और उपयोगकर्ता की समीक्षा के लिए प्रत्येक फ़ाइल के लिए एक अंतर (diff) उत्पन्न करेगा; इस बिंदु पर, उपयोगकर्ता यह तय करता है कि कौन से परिवर्तनों को स्वीकार करना और लागू करना है। यदि ये परिवर्तन नई समस्याएं पेश करते हैं, तो कर्सर मनमाने ढंग से तब तक संशोधन जारी नहीं रखेगा जब तक कि उपयोगकर्ता "दिखी हुई समस्याओं को ठीक करें" जैसे आगे के अनुरोध न करे। यह तंत्र महत्वपूर्ण निर्णय बिंदुओं पर मानव पर्यवेक्षण सुनिश्चित करता है, AI को अनियंत्रित होने से रोकता है। हालांकि, इसका यह भी मतलब है कि कर्सर के एजेंट में लंबी-श्रृंखला योजना के लिए स्वायत्तता की कमी है, जटिल बंद लूप को पूरा करने के लिए चरण-दर-चरण मानव मार्गदर्शन की आवश्यकता होती है। निरंतर स्वायत्तता में आंशिक सुधार के लिए, कर्सर टीम ने एजेंट सिस्टम में कुछ पुनरावृत्ति सुविधाएँ भी जोड़ी हैं। उदाहरण के लिए, यह कोड को संकलित और चलाने का प्रयास करेगा और त्रुटियों को पकड़ेगा, सिंटैक्स या लिंट त्रुटियों जैसी कुछ सरल समस्याओं को स्वचालित रूप से ठीक करेगा, लेकिन आमतौर पर कुछ प्रयासों के बाद रुक जाता है, नियंत्रण उपयोगकर्ता को वापस कर देता है। डेवलपर्स ने देखा है कि कर्सर का एजेंट स्थानीय रीफैक्टरिंग या सीमित दायरे के परिवर्तनों में बहुत कुशलता से प्रदर्शन करता है, लेकिन व्यापक परिवर्तनों के लिए, इसे अक्सर उपयोगकर्ता को खंडों में प्रॉम्प्ट करने की आवश्यकता होती है, जिससे कार्य चरण-दर-चरण पूरा होता है। कुल मिलाकर, कर्सर एजेंट को एक "स्मार्ट निष्पादन सहायक" के रूप में रखता है, न कि एक सर्व-शक्तिशाली स्वचालित प्रोग्रामिंग रोबोट के रूप में; इसकी कार्य योजना अल्पकालिक निष्पादन, समय पर रिपोर्टिंग और मनुष्यों को अगला कदम तय करने देने की ओर झुकती है।

**मॉडल आह्वान रणनीति:** कर्सर अपने स्वयं के बड़े भाषा मॉडल को प्रशिक्षित नहीं करता है; यह तीसरे पक्ष के API को एकीकृत करने की रणनीति अपनाता है। उपयोगकर्ता कर्सर के भीतर OpenAI या Anthropic जैसे विक्रेताओं से API कुंजियों को कॉन्फ़िगर कर सकते हैं, और फिर कर्सर का बैकएंड उपयोगकर्ता की ओर से संबंधित बड़े मॉडल को कॉल करेगा। उपयोगकर्ता किसी भी मॉडल प्रदाता को चुने, सभी AI अनुरोध कर्सर के अपने सर्वर से होकर गुजरेंगे: स्थानीय एप्लिकेशन संपादक संदर्भ और उपयोगकर्ता के प्रश्नों को पैक करता है और उन्हें क्लाउड पर भेजता है, कर्सर का सर्वर पूर्ण प्रॉम्प्ट को इकट्ठा करता है और मॉडल को कॉल करता है, और फिर परिणामों को संपादक को वापस करता है। यह आर्किटेक्चर कर्सर के प्रॉम्प्ट के अनुकूलन और सत्र स्थितियों के एकीकृत प्रबंधन को सुविधाजनक बनाता है, लेकिन इसका यह भी मतलब है कि इसे ऑनलाइन उपयोग किया जाना चाहिए, और कोर AI फ़ंक्शन ऑफ़लाइन मोड में अनुपलब्ध हैं। डेवलपर लागत विचारों के लिए, कर्सर उपयोगकर्ताओं को अपने स्वयं के API कोटा का उपयोग करने का समर्थन करता है (इसलिए मॉडल आह्वान बिलिंग उपयोगकर्ता के पास जाती है), लेकिन फिर भी, अनुरोध अभी भी कोड एम्बेडिंग पुनर्प्राप्ति और प्रतिक्रिया स्वरूपण जैसे ऑपरेशंस के लिए आधिकारिक सर्वर से होकर गुजरते हैं। मॉडल चयन के संदर्भ में, कर्सर आमतौर पर चुनने के लिए कुछ मुख्यधारा के मॉडल प्रदान करता है (जैसे, GPT-4, GPT-3.5, Claude 2, आदि); उपयोगकर्ता एक को पसंद कर सकते हैं, लेकिन कर्सर द्वारा समर्थित नहीं किए गए मॉडल तक पहुंच नहीं सकते हैं। इसके विपरीत, विंडसर्फ जैसे सिस्टम अंतर्निहित इंजन को बदलने की अनुमति देते हैं, जबकि कर्सर अधिक बंद है, मॉडल अपडेट और समायोजन मुख्य रूप से आधिकारिक टीम द्वारा नियंत्रित होते हैं। इसके अतिरिक्त, कर्सर के पास कोपायलट एंटरप्राइज जैसे स्थानीय परिनियोजन समाधान नहीं हैं, न ही यह ओपन-सोर्स मॉडल को एकीकृत करता है—यह पूरी तरह से क्लाउड-सेवा उन्मुख है, इसलिए यह नवीनतम बड़े मॉडल संस्करणों के साथ तेज़ी से तालमेल बिठा सकता है, लेकिन इसके लिए उपयोगकर्ताओं को इसकी क्लाउड प्रोसेसिंग पर भरोसा करने और प्रासंगिक गोपनीयता नीतियों का पालन करने की भी आवश्यकता होती है। यह उल्लेख करना उचित है कि कर्सर एक "थिंकिंग मोड" प्रदान करता है; उपयोगकर्ता प्रतिक्रिया के अनुसार, इसे सक्षम करने से AI प्रतिक्रिया

### विंडसर्फ (कोडियम) एजेंट आर्किटेक्चर

**आर्किटेक्चरल डिज़ाइन फिलॉसफी:** विंडसर्फ कोडियम टीम द्वारा लॉन्च किया गया एक एआई-संचालित प्रोग्रामिंग उत्पाद है, जिसे उद्योग के पहले "एजेंटिक आईडीई" (इंटेलिजेंट एजेंट इंटीग्रेटेड डेवलपमेंट एनवायरनमेंट) के रूप में स्थापित किया गया है। कोपायलट के विपरीत, जिसमें चैट/एजेंट मोड के बीच स्विच करने की आवश्यकता होती है, विंडसर्फ का एआई सहायक (जिसका नाम कैस्केड है) में पूरे समय एजेंट क्षमताएं होती हैं, जो आवश्यकतानुसार प्रश्नों का उत्तर देने और स्वायत्त रूप से बहु-चरणीय कार्यों को निष्पादित करने के बीच सहजता से स्विच करता है। कोडियम आधिकारिक तौर पर अपने दर्शन को "फ्लो = एजेंट + कोपायलट" के रूप में सारांशित करता है। एक फ्लो का तात्पर्य डेवलपर्स और एआई के समकालिक सहयोगात्मक स्थिति में होने से है: एआई किसी भी समय एक सहायक की तरह सुझाव प्रदान करता है और आवश्यकता पड़ने पर सक्रिय रूप से कार्यभार संभाल सकता है और संचालन की एक श्रृंखला को निष्पादित कर सकता है, जबकि पूरी प्रक्रिया डेवलपर के संचालन के साथ वास्तविक समय में सिंक्रनाइज़ेशन में रहती है। इस आर्किटेक्चर में कोई स्पष्ट मानव-मशीन भूमिका स्विचिंग बिंदु नहीं हैं; एआई लगातार डेवलपर की गतिविधियों को "सुनता" रहता है और ताल के अनुकूल ढल जाता है। जब आप विंडसर्फ में कैस्केड के साथ चैट करते हैं, तो यह सीधे आपके प्रश्नों का उत्तर दे सकता है या आपके कथन को एक कार्य के रूप में व्याख्या कर सकता है, फिर संचालन की एक श्रृंखला को ट्रिगर कर सकता है। उदाहरण के लिए, यदि कोई उपयोगकर्ता बातचीत में कैस्केड को बस इतना बताता है, "कृपया उपयोगकर्ता प्रमाणीकरण लागू करें और संबंधित कोड अनुभागों को अपडेट करें," तो कैस्केड स्वचालित रूप से इसे एक क्रॉस-मॉड्यूल आवश्यकता के रूप में समझ सकता है: यह उपयोगकर्ता प्रमाणीकरण से संबंधित फ़ाइलों का पता लगाने के लिए कोडबेस को खोजेगा, इन फ़ाइलों को खोलेगा और संपादित करेगा (उदाहरण के लिए, प्रमाणीकरण फ़ंक्शन जोड़ना, नए कॉन्फ़िगरेशन बनाना, कॉलिंग लॉजिक को संशोधित करना), यदि आवश्यक हो तो प्रोजेक्ट परीक्षण चलाएगा, और अंत में उपयोगकर्ता को पूर्णता स्थिति की रिपोर्ट करेगा। पूरी प्रक्रिया के दौरान, डेवलपर को मोड स्विच करने या चरण-दर-चरण प्रॉम्प्ट करने की आवश्यकता नहीं होती है। बहु-मोडालिटी के संदर्भ में, वर्तमान विंडसर्फ/कैस्केड मुख्य रूप से कोड टेक्स्ट डोमेन पर केंद्रित है और अभी तक छवि या ऑडियो पार्सिंग के लिए समर्थन का उल्लेख नहीं किया है। हालांकि, "डेवलपर के इरादे" पर कैस्केड की पकड़ केवल शुद्ध टेक्स्ट इनपुट से ही नहीं, बल्कि आईडीई वातावरण में विभिन्न संकेतों से भी आती है (नीचे संदर्भ अनुभाग देखें)। कुल मिलाकर, विंडसर्फ का आर्किटेक्चरल दर्शन एआई को आईडीई में एकीकृत करना है: विकास दक्षता को अधिकतम करने के लिए एक निष्क्रिय प्रश्न-उत्तर उपकरण से एक सक्रिय सहयोगी भागीदार में विकसित होना।

**कार्य अपघटन और स्वायत्तता:** कैस्केड में वर्तमान उत्पादों में सबसे मजबूत स्वायत्त ऑर्केस्ट्रेशन क्षमताओं में से एक है। उपयोगकर्ता द्वारा दिए गए उच्च-स्तरीय निर्देशों के लिए, यह पहले व्यापक इरादा विश्लेषण और दायरे का मूल्यांकन करता है, फिर लक्ष्य प्राप्त करने के लिए स्वचालित रूप से विशिष्ट कार्यों की एक श्रृंखला शुरू करता है। नई प्रमाणीकरण कार्यक्षमता जोड़ने के उदाहरण में, कैस्केड निम्नलिखित आंतरिक चरणों को निष्पादित कर सकता है: 1) संशोधन या निर्माण की आवश्यकता वाले मॉड्यूल (उदाहरण के लिए, उपयोगकर्ता मॉडल, प्रमाणीकरण सेवा, कॉन्फ़िगरेशन, यूआई घटक, आदि) को खोजने के लिए प्रोजेक्ट को स्कैन करें; 2) फ़ंक्शन जोड़ने, कॉल समायोजित करने और कॉन्फ़िगरेशन अपडेट करने सहित संबंधित कोड परिवर्तन उत्पन्न करें; 3) फ़ाइलें खोलने और संशोधन सम्मिलित करने के लिए विंडसर्फ द्वारा प्रदान किए गए उपकरणों का उपयोग करें; 4) यह जांचने के लिए मौजूदा टेस्ट सूट चलाएं या एक विकास सर्वर शुरू करें कि क्या नए परिवर्तन सही ढंग से काम कर रहे हैं। यदि परीक्षणों से समस्याएं सामने आती हैं, तो कैस्केड रुकेगा नहीं और मानवीय हस्तक्षेप का इंतजार नहीं करेगा, बल्कि त्रुटि का विश्लेषण करना, बग का पता लगाना, स्वचालित रूप से कोड को संशोधित करना और सत्यापन के लिए फिर से परीक्षण चलाना जारी रखेगा। यह बंद लूप कई राउंड तक जारी रह सकता है जब तक कि कैस्केड को विश्वास न हो जाए कि कार्य पूरा हो गया है या उसे कोई अनसुलझी बाधा नहीं मिलती है। विशेष रूप से, विंडसर्फ डेवलपर को लूप में रखने पर जोर देता है लेकिन उन पर अत्यधिक बोझ डाले बिना। विशेष रूप से, कैस्केड महत्वपूर्ण परिवर्तनों को निष्पादित करने के बाद उपयोगकर्ता को सभी संशोधित फ़ाइलों के लिए अंतर प्रदर्शित करेगा, एक बार की बैच पुष्टि का अनुरोध करेगा। उपयोगकर्ता प्रत्येक अंतर को ब्राउज़ कर सकते हैं और यह तय कर सकते हैं कि परिवर्तनों को स्वीकार करना है या वापस लाना है। यह कदम एआई स्वायत्त रीफैक्टरिंग और कोड सबमिशन के बीच प्रभावी रूप से एक मानव समीक्षा चरण जोड़ता है, न तो एआई के निरंतर संचालन को अत्यधिक बाधित करता है और न ही यह सुनिश्चित करता है कि अंतिम परिणाम मानवीय अपेक्षाओं को पूरा करता है। कर्सर की तुलना में, जिसमें उपयोगकर्ता को प्रत्येक चरण को चलाने की आवश्यकता होती है, विंडसर्फ का कैस्केड डिफ़ॉल्ट स्वायत्तता की ओर झुकता है: उपयोगकर्ता बस आवश्यकता बताता है, और एआई यथासंभव सभी उप-कार्य पूरे करता है, फिर स्वीकृति के लिए उपयोगकर्ता को परिणाम देता है। यह कार्य मोड जटिल संचालन को संभालने में एआई के लाभ का पूरी तरह से उपयोग करता है जबकि 'अंतिम पुष्टि' डिज़ाइन के माध्यम से जोखिम का प्रबंधन करता है।

**मॉडल आह्वान रणनीति:** विंडसर्फ के पीछे की एआई तकनीक मुख्य रूप से कोडियम के स्व-विकसित मॉडल और बुनियादी ढांचे से आती है। कोडियम ने एआई कोडिंग सहायकों के क्षेत्र में अनुभव संचित किया है (इसका कोडियम प्लगइन कोपायलट-जैसी पूर्णता सुविधाएँ प्रदान करता है), और यह अनुमान लगाया गया है कि कैस्केड द्वारा उपयोग किया जाने वाला मॉडल कोडियम का प्रोग्रामिंग के लिए अनुकूलित बड़ा भाषा मॉडल है (संभवतः ओपन-सोर्स मॉडल के आधार पर फाइन-ट्यून किया गया, या कई मॉडलों को एकीकृत करना)। एक स्पष्ट अंतर यह है कि कोडियम उद्यम उपयोगकर्ताओं के लिए सेल्फ-होस्टिंग विकल्प प्रदान करता है, जिसका अर्थ है कि विंडसर्फ द्वारा उपयोग किए जाने वाले मॉडल और अनुमान सेवाओं को कंपनी के अपने सर्वर पर तैनात किया जा सकता है। इसका मतलब है कि आर्किटेक्चरल रूप से, कोडियम OpenAI जैसे तीसरे पक्ष के एपीआई पर निर्भर नहीं करता है; इसके कोर मॉडल कोडियम द्वारा प्रदान किए जा सकते हैं और ग्राहक के वातावरण में चलाए जा सकते हैं। वास्तव में, कोडियम प्लेटफॉर्म "इंजन" की अवधारणा का समर्थन करता है, जहां उपयोगकर्ता एआई बैकएंड इंजन चुन सकते हैं, उदाहरण के लिए, कोडियम के अपने मॉडल "सॉनेट" (कोडियम के आंतरिक मॉडल कोडनेम में से एक) या एक ओपन-सोर्स मॉडल विकल्प का उपयोग करना। यह डिज़ाइन सैद्धांतिक रूप से विंडसर्फ को मॉडल लचीलापन देता है: यदि आवश्यक हो, तो यह किसी अन्य समकक्ष मॉडल इंजन पर स्विच कर सकता है, कर्सर के विपरीत, जो केवल आधिकारिक टीम द्वारा सूचीबद्ध कुछ निश्चित मॉडलों का उपयोग कर सकता है। वर्तमान डिफ़ॉल्ट कॉन्फ़िगरेशन के तहत, विंडसर्फ की अधिकांश बुद्धिमत्ता कोडियम की ऑनलाइन सेवाओं से आती है, और इसका अनुमान भी क्लाउड में किया जाता है। हालांकि, कर्सर के विपरीत, जो पूरी तरह से दूरस्थ सेवाओं पर निर्भर करता है, विंडसर्फ ने स्थानीय रूप से कुछ एआई कार्यों को अनुकूलित किया है: उदाहरण के लिए, टैब पूर्णता (सुपरकंप्लीट) सुविधा, आधिकारिक जानकारी के अनुसार, कोडियम के स्व-विकसित छोटे मॉडल द्वारा संचालित है, जो स्थानीय/निकटवर्ती सर्वर पर उच्च गति से चल रहा है। यह दैनिक कोडिंग के दौरान तत्काल सुझावों को विलंबता के संदर्भ में लगभग अगोचर बनाता है, जबकि जटिल वार्तालापों या बड़े पैमाने पर पीढ़ी के लिए शक्तिशाली क्लाउड मॉडल को बुलाया जाता है। डेटा सुरक्षा की परवाह करने वाले उद्यम ग्राहकों के लिए, विंडसर्फ का सबसे बड़ा विक्रय बिंदु "एयर-गैप्ड" परिनियोजन के लिए इसका समर्थन है: कंपनियां अपने फ़ायरवॉल के भीतर पूर्ण कोडियम एआई इंजन स्थापित कर सकती हैं, और सभी कोड और प्रॉम्प्ट डेटा आंतरिक नेटवर्क के भीतर रहते हैं। इसलिए, विंडसर्फ ने अपनी मॉडल रणनीति में कर्सर के विपरीत विकल्प चुना है - अग्रणी एआई कंपनियों के एपीआई पर पूरी तरह निर्भर रहने के बजाय, अधिक मॉडल स्वायत्तता और परिनियोजन लचीलेपन के लिए प्रयास करना। इस विकल्प के लिए अधिक इंजीनियरिंग निवेश की आवश्यकता है (स्वामित्व वाले मॉडल को प्रशिक्षित करना और बनाए रखना, साथ ही जटिल परिनियोजन समर्थन), लेकिन इसने उद्यम बाजार में मान्यता प्राप्त की है। यह कोडियम की इंजीनियरिंग डिजाइन प्राथमिकताओं में से एक भी है।

**स्थिति प्रबंधन और संदर्भ प्रतिधारण:** चूंकि लक्षित उपयोगकर्ताओं में बड़ी कोड रिपॉजिटरी को संभालने वाली टीमें शामिल हैं, विंडसर्फ ने संदर्भ प्रबंधन के लिए इंजीनियरिंग डिजाइन में भारी निवेश किया है। इसका मूल कोड अनुक्रमण और पुनर्प्राप्ति तंत्र का एक सेट है: जब कोई उपयोगकर्ता एक रिपॉजिटरी खोलता है, तो विंडसर्फ स्वचालित रूप से सभी कोड को स्कैन करता है और स्थानीय रूप से एक सिमेंटिक इंडेक्स बनाता है (वेक्टर एम्बेडिंग का उपयोग करके)। यह प्रक्रिया एक प्रोजेक्ट पूर्ण-पाठ खोज बनाने के समान है, लेकिन अधिक स्मार्ट - इंडेक्स एआई को उस फ़ाइल को स्पष्ट रूप से लोड किए बिना मांग पर किसी भी फ़ाइल से प्रासंगिक सामग्री को पुनः प्राप्त करने की अनुमति देता है। इसलिए, जब कैस्केड को कई फ़ाइलों से जुड़े प्रश्नों का उत्तर देने की आवश्यकता होती है, तो यह इंडेक्स से प्रासंगिक स्निपेट्स को जल्दी से ढूंढ सकता है और उनकी सामग्री को मॉडल संदर्भ में जोड़ सकता है। उदाहरण के लिए, यदि आप पूछते हैं "फ़ंक्शन X कहाँ परिभाषित है?", तो कैस्केड तुरंत इंडेक्स के माध्यम से परिभाषा का पता लगा सकता है और एक उत्तर प्रदान कर सकता है, भले ही उसने उस फ़ाइल को कभी नहीं खोला हो। यह "वैश्विक संदर्भ जागरूकता" बड़े प्रोजेक्ट्स को समझने की एआई की क्षमता को बहुत बढ़ाती है क्योंकि यह संदर्भ विंडो की भौतिक सीमाओं को तोड़ता है, अनिवार्य रूप से एआई को प्रोजेक्ट के बारे में एक तत्काल क्वेरी डेटाबेस देता है। इसके अलावा, विंडसर्फ दीर्घकालिक स्मृति पर बहुत जोर देता है, "मेमोरीज" सुविधा पेश करता है। मेमोरीज को दो श्रेणियों में बांटा गया है: एक उपयोगकर्ता-परिभाषित "नोट्स" या "नियम" हैं, जहां डेवलपर्स सक्रिय रूप से कैस्केड को कुछ स्थायी जानकारी (उदाहरण के लिए, प्रोजेक्ट आर्किटेक्चर विवरण, कोडिंग स्टाइल गाइड, आदि) प्रदान कर सकते हैं, जिसे स्थायी रूप से संग्रहीत किया जाएगा और प्रासंगिक होने पर मॉडल को संदर्भ के लिए प्रदान किया जाएगा। दूसरी श्रेणी स्वचालित रूप से रिकॉर्ड की गई यादें हैं, जैसे एआई और उपयोगकर्ता के बीच पिछली बातचीत का सारांश, प्रोजेक्ट पर एआई द्वारा लिए गए महत्वपूर्ण निर्णय, आदि, जिन्हें भी संग्रहीत किया जाता है। जब आप कुछ दिनों बाद विंडसर्फ को फिर से खोलते हैं, तो कैस्केड अभी भी पहले से चर्चा की गई सामग्री और निष्कर्षों को "याद" रखता है, आपको फिर से समझाने की आवश्यकता नहीं होती है। यह ChatGPT-शैली की बातचीत स्मृति को क्रॉस-सेशन आयामों तक विस्तारित करने के बराबर है। कार्यान्वयन के संदर्भ में, मेमोरीज को एक स्थानीय डेटाबेस या उपयोगकर्ता कॉन्फ़िगरेशन फ़ाइलों के माध्यम से लागू किया जाना चाहिए, यह सुनिश्चित करते हुए कि केवल उपयोगकर्ता या टीम ही उन तक पहुंच सके। वैश्विक अनुक्रमण और मेमोरीज के अलावा, विंडसर्फ में एक अद्वितीय संदर्भ स्रोत है: वास्तविक समय डेवलपर व्यवहार। क्योंकि कैस्केड आईडीई में पूरी तरह से एकीकृत है, यह आईडीई में आपकी गतिविधियों को वास्तविक समय में समझ सकता है। उदाहरण के लिए, आपका कर्सर कहाँ स्थित है, आप कौन सा कोड संपादित कर रहे हैं, या आप कौन से टर्मिनल कमांड चलाते हैं - कैस्केड यह जानकारी प्राप्त कर सकता है और इसे बातचीत संदर्भ में एकीकृत कर सकता है। कोडियम इसे "आपकी गतिविधियों की वास्तविक समय जागरूकता" कहता है। एक परिदृश्य पर विचार करें: यदि आपने अभी-अभी परीक्षण चलाए हैं, तो कैस्केड परीक्षण आउटपुट पढ़ सकता है, पा सकता है कि एक यूनिट परीक्षण विफल हो गया है, और सक्रिय रूप से एक समाधान सुझा सकता है - भले ही आपने इसे देखने के लिए विफलता लॉग को स्पष्ट रूप से कॉपी न किया हो। या, यदि आप एक फ्रंटएंड कोड फ़ाइल खोलते हैं, तो कैस्केड तुरंत उस फ़ाइल को खींचता है और पृष्ठभूमि में उसका विश्लेषण करता है, ताकि जब आप एक संबंधित प्रश्न पूछें, तो कोई देरी न हो। मानवीय संचालन का यह वास्तविक समय अनुसरण मानव-मशीन सहयोग को अधिक स्वाभाविक और तरल बनाता है, जैसे कि कैस्केड एक सहायक है जो लगातार आपकी स्क्रीन देख रहा है। संक्षेप में,

### सिस्टम तुलना सारांश

नीचे GitHub Copilot, Cursor, और Windsurf के एजेंट आर्किटेक्चर में समानताओं और भिन्नताओं का एक अवलोकन प्रदान करने वाली एक तालिका दी गई है:

| विशेषता आयाम                       | GitHub Copilot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Cursor                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Windsurf (Codeium)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ---------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **आर्किटेक्चरल पोजिशनिंग**         | प्रोग्रामिंग सहायता के लिए एक चैट बॉट के रूप में शुरू हुआ, "एजेंट मोड" (कोडनेम प्रोजेक्ट पाडावन) तक विस्तारित; एजेंट को GitHub प्लेटफॉर्म में एम्बेड किया जा सकता है, इश्यू/PR वर्कफ़्लो के साथ एकीकृत किया जा सकता है। मल्टी-टर्न वार्तालाप एकल एजेंट, कोई स्पष्ट मल्टी-एजेंट आर्किटेक्चर नहीं। मल्टी-मोडल इनपुट (छवियों) का समर्थन करता है।                                                                                                                                                                                                                                                                                                                                                        | AI-फर्स्ट लोकल एडिटर (VS कोड डेरिवेटिव), इसमें चैट मोड और एजेंट मोड इंटरैक्शन शामिल हैं। डिफ़ॉल्ट असिस्टेंट मोड Q&A और पूर्णता पर केंद्रित है, AI को स्वायत्त रूप से कार्य निष्पादित करने के लिए एजेंट मोड को स्पष्ट सक्रियण की आवश्यकता होती है। एकल एजेंट आर्किटेक्चर, कोई मल्टी-मोडल प्रोसेसिंग नहीं।                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | शुरुआत से ही एक "एजेंटिक IDE" के रूप में डिज़ाइन किया गया: AI असिस्टेंट कैस्केड हमेशा ऑनलाइन रहता है, जो चैटिंग और स्वायत्त मल्टी-स्टेप ऑपरेशंस दोनों में सक्षम है, किसी मोड स्विचिंग की आवश्यकता नहीं है। एकल एजेंट निष्पादन, फ्लो के माध्यम से मानव और AI के बीच सिंक्रोनस सहयोग प्राप्त करता है, वर्तमान में कोड टेक्स्ट पर केंद्रित है।                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| **कार्य योजना और निष्पादन**        | स्वचालित कार्य अपघटन और पुनरावृत्तीय निष्पादन का समर्थन करता है। एजेंट उपयोगकर्ता अनुरोधों को उप-कार्यों में तोड़ता है और लक्ष्य प्राप्त होने तक या स्पष्ट रूप से रोके जाने तक उन्हें पुनरावृत्तीय रूप से पूरा करता है। इसमें आत्म-उपचार क्षमताएं हैं (संकलन/परीक्षण त्रुटियों की पहचान और उन्हें ठीक कर सकता है)। प्रत्येक कार्य पूर्ण होने के बाद PRs के रूप में परिणाम देता है और मानव समीक्षा की प्रतीक्षा करता है; समीक्षा प्रतिक्रिया अगली पुनरावृत्ति को ट्रिगर करती है।                                                                                                                                                                                                                      | क्रॉस-फाइल संशोधनों को संभाल सकता है लेकिन एकल-टर्न निष्पादन की ओर झुकता है: एजेंट निर्देश प्राप्त करता है और एक साथ सभी संशोधन सुझाव प्रदान करता है, उपयोगकर्ता की स्वीकृति के लिए अंतरों को सूचीबद्ध करता है। आमतौर पर कई मोड़ों में स्वायत्त रूप से पुनरावृति नहीं करता है (जब तक कि उपयोगकर्ता फिर से संकेत न दे), और त्रुटियों को अक्सर उपयोगकर्ता पर छोड़ दिया जाता है कि AI उन्हें ठीक करे या नहीं। डिफ़ॉल्ट रूप से केवल सीमित संख्या में स्वचालित सुधार चक्र करता है, जिससे अनिश्चितकालीन लटकने से बचा जा सके।                                                                                                                                                                                                                                                                         | गहरी स्वायत्तता: कैस्केड उच्च-स्तरीय आवश्यकताओं को कई क्रियाओं में तोड़ सकता है और कार्य पूरा होने तक लगातार निष्पादित कर सकता है। बड़े रिफैक्टरिंग और क्रॉस-मॉड्यूल कार्यों में उत्कृष्ट है, संपादन, फ़ाइल निर्माण, कमांड निष्पादन, परीक्षण सत्यापन आदि के लिए कॉल को स्वचालित रूप से श्रृंखलाबद्ध करता है, जब तक कि कोड आत्म-जांच पास न कर ले। यदि प्रक्रिया के दौरान नई समस्याएं पाई जाती हैं, तो यह उन्हें पुनरावृति और ठीक करना जारी रखता है, अंतिम परिणाम को छोड़कर लगभग कोई मानवीय हस्तक्षेप की आवश्यकता नहीं होती है (लेकिन महत्वपूर्ण परिवर्तनों के लिए मानव अंतिम पुष्टि की आवश्यकता होगी)।                                                                                                                                                                                           |
| **मॉडल रणनीति**                    | क्लाउड मल्टी-मॉडल फ्यूजन: OpenAI GPT-4, GPT-3.5 श्रृंखला (आंतरिक कोडनेम o1, o3-mini, आदि), Anthropic Claude 3.5, Google Gemini 2.0, आदि का समर्थन करता है, और उपयोगकर्ता इंटरफ़ेस में पसंदीदा मॉडल स्विच कर सकते हैं। दोहरी-मॉडल आर्किटेक्चर (बड़ा मॉडल समाधान उत्पन्न करता है, छोटा मॉडल जल्दी से परिवर्तन लागू करता है) के माध्यम से दक्षता में सुधार करता है। मॉडल GitHub द्वारा समान रूप से होस्ट और इनवोक किए जाते हैं; Copilot Enterprise उपयोगकर्ता अनुरोध समर्पित इंस्टेंस के माध्यम से जाते हैं। निजी परिनियोजन का समर्थन नहीं करता है।                                                                                                                                                     | पूरी तरह से थर्ड-पार्टी बड़े मॉडल API पर निर्भर करता है: सभी अनुरोध Cursor के क्लाउड के माध्यम से रिले किए जाते हैं और OpenAI/Anthropic मॉडल को इनवोक करते हैं। उपयोगकर्ता अपनी API कुंजी (बिलिंग स्वयं-प्रबंधित) का उपयोग कर सकते हैं लेकिन इनवोकेशन अभी भी आधिकारिक सर्वर पर होता है। कोई ऑफ़लाइन या स्थानीय मॉडल विकल्प नहीं। मॉडल प्रकार Cursor की समर्थित सीमा पर निर्भर करते हैं; उपयोगकर्ता स्वतंत्र रूप से नए मॉडल को एकीकृत नहीं कर सकते। Cursor सीधे मॉडल को प्रशिक्षित नहीं करता है बल्कि प्रॉम्प्ट को अनुकूलित करके बाहरी मॉडल को अनुकूलित करता है।                                                                                                                                                                                                                                | मुख्य रूप से स्व-विकसित मॉडल, लचीला बैकएंड: डिफ़ॉल्ट रूप से Codeium के मालिकाना कोड मॉडल का उपयोग करता है, और उद्यम उपयोगकर्ताओं को स्व-होस्टेड परिनियोजन चुनने की अनुमति देता है। आर्किटेक्चर विभिन्न मॉडल इंजनों (Codeium "Sonnet" मॉडल या ओपन सोर्स, आदि) को बदलने का समर्थन करता है, और भविष्य में थर्ड-पार्टी इंटरफेस का विस्तार कर सकता है। कुछ हल्के कार्य स्थानीय/एज कंप्यूटिंग के लिए छोटे मॉडल का उपयोग विलंबता को कम करने के लिए करते हैं। AI वातावरण पर उपयोगकर्ता नियंत्रण पर जोर देता है (मॉडल अपडेट की गति, उपयोगकर्ता द्वारा नियंत्रित संस्करण स्थिरता)।                                                                                                                                                                                                                        |
| **संदर्भ और स्मृति**               | कोड संदर्भ प्राप्त करने के लिए RAG रणनीति का उपयोग करता है: GitHub कोड खोज के माध्यम से प्रासंगिक कोड स्निपेट्स को पुनः प्राप्त करता है और उन्हें प्रॉम्प्ट में इंजेक्ट करता है। प्रॉम्प्ट में टोकन बचाने के लिए पूर्ण टेक्स्ट के बजाय परियोजना संरचना सारांश शामिल होता है। कार्य इरादे और परियोजना मानकों को समझने के लिए संदर्भ में इश्यू विवरण, संबंधित PR चर्चाओं को शामिल करने का समर्थन करता है। वार्तालाप इतिहास एक ही सत्र के भीतर बनाए रखा जाता है; कोई स्वचालित क्रॉस-सत्र स्मृति नहीं (क्रॉस-सत्र जानकारी ले जाने के लिए इश्यू/PRs या READMEs पर निर्भरता की आवश्यकता होती है)।                                                                                                          | सिमेंटिक खोज का समर्थन करने के लिए स्टार्टअप पर परियोजना के लिए वेक्टर इंडेक्स बनाता है। मॉडल प्रॉम्प्ट वर्तमान में उपयोगकर्ता द्वारा प्रदान किए गए कोड संदर्भ (खुली फाइलें या स्निपेट्स) पर केंद्रित होते हैं; जब अन्य भागों की आवश्यकता होती है, तो उन्हें सिमेंटिक प्रासंगिकता के माध्यम से पुनः प्राप्त किया जाता है और डाला जाता है। `.cursor/rules` फ़ाइल तंत्र प्रदान करता है, जिससे डेवलपर्स परियोजना के लिए स्थायी ज्ञान और मानक निर्धारित कर सकते हैं; एजेंट प्रत्येक वार्तालाप में इन नियमों को पढ़ता है, जो मानव-प्रदत्त दीर्घकालिक स्मृति के बराबर है। डिफ़ॉल्ट रूप से कोई स्वचालित क्रॉस-सत्र स्मृति नहीं (उपयोगकर्ता को नियम फ़ाइलों में मैन्युअल रूप से रिकॉर्ड करने की आवश्यकता होती है)।                                                                                     | पूर्ण परियोजना सिमेंटिक अनुक्रमण: स्थानीय रूप से पूरे कोडबेस को स्कैन करके एक इंडेक्स बनाता है; कैस्केड किसी भी समय किसी भी फ़ाइल सामग्री को संदर्भ के रूप में पुनः प्राप्त कर सकता है। इसमें एक मेमोरीज सिस्टम है जो महत्वपूर्ण वार्तालाप सामग्री और उपयोगकर्ता-निर्दिष्ट नोट्स/नियमों को स्वचालित रूप से और लगातार सहेजता है, जिससे क्रॉस-सत्र स्मृति प्राप्त होती है। इस प्रकार, कैस्केड पुनरारंभ करने के बाद भी परियोजना के सम्मेलनों और पिछली चर्चाओं को "याद" रखता है। IDE पर्यावरण स्थिति को भी एक संदर्भ स्रोत के रूप में एकीकृत करता है: उपयोगकर्ता द्वारा खोली गई फ़ाइलों, कर्सर स्थिति, टर्मिनल आउटपुट आदि की वास्तविक समय की धारणा, उपयोगकर्ता के इरादे को समझने के लिए इस निहित जानकारी का उपयोग करता है। कुल मिलाकर, कैस्केड का एक व्यापक और अधिक गतिशील संदर्भ दृश्य है।         |
| **उपकरण और एक्सटेंशन**             | GitHub वर्कफ़्लो के साथ गहरा एकीकरण: एजेंट GitHub Actions के माध्यम से क्लाउड में एक अलग विकास वातावरण प्राप्त करता है, जो यूनिट परीक्षणों को निष्पादित करने, परियोजनाओं को चलाने आदि में सक्षम है। अंतर्निहित उपकरणों में फ़ाइलें पढ़ना, रिपॉजिटरी खोजना, कोड परिवर्तन लागू करना, टर्मिनल कमांड आदि शामिल हैं, जिन्हें LLM आवश्यकतानुसार कॉल कर सकता है। MCP (मॉडल संदर्भ प्रोटोकॉल) मानक प्रस्तुत करता है, जो बाहरी डेटा स्रोतों और सेवाओं से कनेक्शन का समर्थन करता है; आधिकारिक MCP प्लगइन्स GitHub डेटा तक पहुंच सकते हैं, और थर्ड-पार्टी एक्सटेंशन के लिए एक वैश्विक खुला इंटरफ़ेस। कंप्यूटर विजन क्षमताओं से लैस है, इश्यू से जुड़ी स्क्रीनशॉट को समस्या के आधार के रूप में पार्स कर सकता है। | समृद्ध IDE हेरफेर उपकरण प्रदान करता है, सिस्टम प्रॉम्प्ट द्वारा ठीक से निर्देशित किया जाता है कि उनका उपयोग कैसे करें (उदाहरण के लिए, AI को संशोधित करने से पहले फ़ाइल सामग्री पढ़ने की आवश्यकता होती है, संदर्भ पर आधारित न होने वाली अंधाधुंध लेखन से बचना)। MCP इंटरफ़ेस के माध्यम से प्लगइन-क्षमता प्राप्त करता है, कस्टम टूल/डेटा स्रोतों से कनेक्शन की अनुमति देता है ताकि एजेंट क्षमताओं का विस्तार किया जा सके। उदाहरण के लिए, डेवलपर्स एक डेटाबेस क्वेरी प्लगइन जोड़ सकते हैं ताकि कर्सर एजेंट कोड में नवीनतम डेटाबेस स्कीमा जानकारी का उपयोग कर सके। कर्सर एजेंट उपकरण उपयोग के लिए पूर्वनिर्धारित नियमों का कड़ाई से पालन करता है (उदाहरण के लिए, कॉल करने से पहले कार्यों की व्याख्या करना), जिससे इंटरैक्शन की पूर्वानुमेयता में सुधार होता है।                                   | सबसे व्यापक उपकरण एकीकरण: कैस्केड का संपादक और सिस्टम पर व्यापक परिचालन नियंत्रण है, फ़ाइल सिस्टम से टर्मिनल तक। स्वचालित कमांड निष्पादन (जैसे, बिल्ड, टेस्ट) और बाद की कार्रवाइयों के लिए परिणामों का उपयोग करने का समर्थन करता है। वेव 3 के बाद से MCP प्लगइन्स का समर्थन करता है, जिससे बाहरी सेवाएं JSON कॉन्फ़िगरेशन के माध्यम से कैस्केड के उपकरण बन सकती हैं, जैसे कि मैप API, डेटाबेस इंटरफेस, आदि। कैस्केड स्मार्ट प्रतिक्रियाओं के लिए IDE स्थिति (क्लिपबोर्ड सामग्री, वर्तमान चयन, आदि) की भी निगरानी करता है। सुरक्षा के लिए, विंडसर्फ को महत्वपूर्ण परिवर्तनों के लिए उपयोगकर्ता पुष्टि और दुरुपयोग को रोकने के लिए बाहरी सेवा कॉल के लिए पूर्व-कॉन्फ़िगरेशन की आवश्यकता होती है। कुल मिलाकर, कैस्केड IDE प्लगइन और शेल स्क्रिप्ट क्षमताओं वाले AI विकास भागीदार के लगभग बराबर है। |
| **इंजीनियरिंग ट्रेड-ऑफ और नवाचार** | प्लेटफ़ॉर्म एकीकरण: एजेंट को होस्ट करने के लिए मौजूदा GitHub इन्फ्रास्ट्रक्चर (एक्शन्स, PR तंत्र, आदि) का पूरी तरह से लाभ उठाता है। सुरक्षा पहले: बिना समीक्षा किए गए कोड को सीधे मुख्य शाखा और उत्पादन वातावरण को प्रभावित करने से रोकने के लिए अंतर्निहित नीतियां। प्रस्तावित MCP खुला मानक, LLMs के लिए बाहरी उपकरणों को कॉल करने के लिए एक सार्वभौमिक समाधान की उद्योग खोज का अग्रणी। पारदर्शिता: उपयोगकर्ताओं को एजेंट निष्पादन लॉग देखने की अनुमति देता है ताकि इसकी निर्णय लेने की प्रक्रिया को समझा जा सके, जिससे विश्वास बढ़ता है। नवाचार AI को विकास वर्कफ़्लो के विभिन्न चरणों में गहराई से एम्बेड करने में निहित है ताकि क्लोज्ड-लूप मानव-AI सहयोगी विकास प्राप्त किया जा सके।           | क्लाउड सेवा: चुनी गई क्लाउड आर्किटेक्चर बड़े मॉडल प्रदर्शन और एकीकृत प्रबंधन सुनिश्चित करती है, लेकिन ऑफ़लाइन क्षमता का त्याग करती है। फाइन-ट्यून किए गए प्रॉम्प्ट: LLMs को पेशेवर कोड सहायक में बदलना सिस्टम प्रॉम्प्ट और उपकरण निर्देशों के विशाल संग्रह पर निर्भर करता है; इस क्षेत्र में कर्सर के निवेश ने इसकी पीढ़ी की गुणवत्ता को अत्यधिक प्रशंसित किया है। मानवीय निरीक्षण: AI को कोड को संशोधित करने की पूरी स्वतंत्रता देने के बजाय मानवीय पुष्टि का एक अतिरिक्त कदम पसंद करता है—यह रूढ़िवादी रणनीति त्रुटि जोखिम को कम करती है और उपयोगकर्ता के विश्वास को बढ़ाती है। अनुकूलन क्षमता: नियम फ़ाइलों और प्लगइन्स के माध्यम से, कर्सर उन्नत उपयोगकर्ताओं को AI व्यवहार को अनुकूलित करने और क्षमताओं का विस्तार करने के तरीके प्रदान करता है, जो एक प्रमुख इंजीनियरिंग लचीलापन लाभ है। | मानव-केंद्रित: प्रारंभिक एजेंट अतुल्यकालिक निष्पादन की कम दक्षता का मुकाबला करने के लिए फ्लो मोड पेश किया, जिससे AI क्रियाओं और मनुष्यों के बीच वास्तविक समय की बातचीत सक्षम हुई। अत्यधिक संदर्भ एकीकरण: स्थानीय कोड अनुक्रमण + क्रॉस-सत्र स्मृति + IDE व्यवहार निगरानी, ​​उद्योग में वर्तमान में सबसे व्यापक सूचना अधिग्रहण एजेंट का निर्माण। उद्यम-अनुकूल: सुरक्षा और अनुपालन आवश्यकताओं को पूरा करने के लिए स्व-विकसित मॉडल और                                                                                                                                                                                                                                                                                                                                                               |
