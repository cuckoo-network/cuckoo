---
title: "GitHub Copilot, Cursor ve Windsurf'ün Ajan Sistem Mimarileri"
tags:
  [
    yapay zeka,
    programlama asistanları,
    GitHub Copilot,
    Cursor,
    Windsurf,
    ajan sistemleri,
  ]
keywords:
  [
    yapay zeka mimarisi,
    GitHub Copilot,
    Cursor,
    Windsurf,
    programlama asistanları,
    ajan sistemleri,
    görev ayrıştırma,
    model çağırma,
    bağlam yönetimi,
  ]
authors: [lark]
description: GitHub Copilot, Cursor ve Windsurf'ün ajan sistem mimarilerinin derinlemesine bir analizi; yapay zeka destekli programlama yardımına etkilerini anlamak için tasarım felsefelerine, görev ayrıştırmasına, model çağırma stratejilerine ve bağlam yönetimine odaklanılmıştır.
image: "https://opengraph-image.blockeden.xyz/api/og-cuckoo-network?title=GitHub%20Copilot%2C%20Cursor%20ve%20Windsurf%27%C3%BCn%20Ajan%20Sistem%20Mimarileri"
---

```

## GitHub Copilot, Cursor ve Windsurf'ün Ajan Sistem Mimarileri

Son yıllarda GitHub Copilot, Cursor ve Windsurf gibi çeşitli yapay zeka programlama asistanı ürünleri ortaya çıktı. Bu ürünlerin uygulamaları, yapay zekanın kodlama çalışmalarına daha proaktif bir şekilde yardımcı olmasını sağlayan "Ajan" (akıllı ajan) kavramını tanıtmaktadır. Bu makale, mimari tasarım felsefesi, görev ayrıştırma ve planlama, model çağırma stratejileri, bağlam durumu yönetimi, eklenti uzatma mekanizmaları ve ilgili tasarımlarındaki temel ödünleşimler ve yenilikler dahil olmak üzere, bu ürünlerin Ajan sistem yapısını mühendislik mimarisi perspektifinden derinlemesine incelemektedir. Aşağıdaki içerik, ağırlıklı olarak resmi mühendislik bloglarına, proje geliştiricilerinin makalelerine ve ilgili teknik materyallere dayanmaktadır.

![](https://opengraph-image.blockeden.xyz/api/og-cuckoo-network?title=GitHub%20Copilot%2C%20Cursor%20ve%20Windsurf%27%C3%BCn%20Ajan%20Sistem%20Mimarileri)

### GitHub Copilot'ın Ajan Mimarisi

**Mimari Tasarım Felsefesi:** GitHub Copilot başlangıçta kendisini bir geliştiricinin "yapay zeka eş programcısı" olarak konumlandırmış, şimdi ise bunu bir "Ajan" modu ile genişletmiştir. Ajan sistemi, bağımsız ajanların bir koleksiyonu değil, çok turlu konuşmalara ve çok adımlı görev yürütmeye katılabilen, çok modlu girişi (örn. ekran görüntülerini yorumlamak için görme modellerini kullanma) destekleyen gömülü bir akıllı ajandır. Copilot, geliştiricilerin yerini almaktan ziyade yapay zeka desteğini vurgular. Ajan modunda, bir ekip içinde otomatik bir mühendis gibi davranır; atanmış görevleri kabul eder, otonom olarak kod yazar, hata ayıklar ve sonuçları Çekme İstekleri (Pull Request) aracılığıyla gönderir. Bu ajan, sohbet arayüzü aracılığıyla veya Copilot'a bir GitHub Sorunu (Issue) atanarak tetiklenebilir.

**Görev Ayrıştırma ve Planlama:** Copilot'ın Ajanı, karmaşık yazılım görevlerini alt görevlere ayırmada ve bunları tek tek tamamlamada üstündür; bu süreçte Düşünce Zinciri'ne (Chain-of-Thought) benzer bir iç muhakeme süreci kullanır. Kullanıcı gereksinimleri karşılanana kadar "problemi analiz et → kod değişikliklerini veya komutları yürüt → sonuçları doğrula" döngüsünü tekrarlar. Örneğin, Ajan Modunda Copilot, kullanıcı tarafından belirtilen adımları yürütmekle kalmaz, aynı zamanda ana hedefe ulaşmak için gereken ek adımları *örtük olarak* çıkarır ve otomatik olarak yürütür. Süreç sırasında derleme hataları veya test başarısızlıkları meydana gelirse, Ajan hataları kendisi tespit eder ve düzeltir, ardından tekrar dener, böylece geliştiricilerin hata mesajlarını tekrar tekrar istem olarak kopyalayıp yapıştırmasına gerek kalmaz. Bir VS Code blogu çalışma döngüsünü şöyle özetler: Copilot Ajanı, ilgili bağlamı ve düzenlenecek dosyaları otonom olarak belirler, çalıştırılacak kod değişikliklerini ve komutları önerir, düzenlemelerin veya terminal çıktısının doğruluğunu izler ve görev tamamlanana kadar sürekli olarak yineler. Bu otomatik çok turlu yürütme, Copilot'ın basit bir uygulama oluşturmaktan birden çok dosyada büyük ölçekli yeniden düzenlemeye kadar çeşitli görevleri yerine getirmesini sağlar.

**Model Çağırma Stratejisi:** GitHub Copilot'ın arkasındaki modeller başlangıçta OpenAI'ın Codex'iydi, şimdi ise daha güçlü bir çoklu model mimarisine yükseltildi. Copilot, kullanıcılara "Model Seçenekleri"nde OpenAI'ın GPT-4'ü (dahili kod adı gpt-4o) ve basitleştirilmiş sürümü, Anthropic'in Claude 3.5'i (kod adı Sonnet) ve Google'ın en son Gemini 2.0 Flash'ı gibi farklı temel modelleri seçme imkanı sunar. Bu çoklu model desteği, Copilot'ın görev gereksinimlerine veya kullanıcı tercihlerine göre model kaynaklarını değiştirebileceği anlamına gelir. Copilot Düzenlemeleri (çoklu dosya düzenleme) işlevselliğinde, GitHub verimliliği artırmak için çift model mimarisi de kullanır: önce seçilen "büyük model" tam bağlamla bir başlangıç düzenleme planı oluşturur, ardından özel bir "spekülatif kod çözme" uç noktası bu değişiklikleri hızla uygular. Spekülatif kod çözücü, büyük model kod değişikliklerini düşünürken düzenleme sonuçlarını önceden oluşturan hafif bir model veya kural motoru olarak görülebilir, böylece gecikmeyi azaltır. Özetle, Copilot'ın model stratejisi, bulutta birden çok son teknoloji LLM'yi entegre etmek, farklı senaryolar için optimize etmek ve mühendislik yollarıyla (çift model boru hattı) yanıt h

---
title: "Cursor'ın Agent Mimarisi"
description: "Cursor, Anysphere tarafından geliştirilen, yapay zeka destekli bir kodlama aracıdır. Sohbet asistanı ve otonom Agent modları sunarak geliştiricilere esnek ve güçlü bir kod düzenleme deneyimi sağlar."
image: "https://opengraph-image.blockeden.xyz/api/og-cuckoo-network?title=Cursor'ın Agent Mimarisi"
---

### Cursor'ın Agent Mimarisi

**Mimari Tasarım Felsefesi:** Cursor, Anysphere girişimi tarafından geliştirilen yapay zeka destekli bir kodlama aracıdır. Esasen, bir yapay zeka asistanıyla derinlemesine entegre edilmiş bir kod düzenleyicidir (VS Code temel alınarak değiştirilmiştir). Cursor iki ana etkileşim modu sunar: sohbet asistanı ve otonom Agent. Normal konuşma modunda, geleneksel bir kod asistanı gibi davranır, soruları yanıtlar veya talimatlara göre kod üretir; Agent moduna ("Composer" olarak da bilinir) geçildiğinde, Cursor geliştirici adına bir dizi işlemi proaktif olarak yürütebilir. Bu mimari, kullanıcılara ihtiyaç duydukları gibi seçim yapma özgürlüğü verir: basit görevler asistan modunda satır satır sorularak halledilebilirken, karmaşık veya tekrarlayan görevler Agent çağrılarak toplu olarak işlenebilir. Cursor şu anda öncelikli olarak metin (kod) alanında yardımcı olmaya odaklanmıştır, çok modlu girdi/çıktıyı vurgulamamaktadır (sesli giriş işlevi sağlamasına rağmen, konuşmayı istemler için metne dönüştürür). Copilot'a benzer şekilde, Cursor'ın Agent sistemi de paralel çalışan birden fazla ajan değil, seri olarak tek bir akıllı ajan olarak çalışır. Ancak, ayırt edici özelliği insan-yapay zeka işbirliğine verdiği önemdir: Agent modunda, yapay zeka mümkün olduğunca çok eylemde bulunur, ancak genel olarak geliştiricilerin istedikleri zaman müdahale etmelerine ve kontrolü ele almalarına izin verir, uzun süreler boyunca tamamen denetimsiz çalışmaz.

**Görev Ayrıştırma ve Planlama:** Cursor'ın Agent modunda, yapay zeka karmaşık dosya içi görevleri halledebilir, ancak tasarım adım adım istek stiline yöneliktir. Kullanıcıdan üst düzey bir talimat aldıktan sonra, Agent ilgili kod parçacıklarını otonom olarak arar, düzenlenmesi gereken dosyaları açar, değişiklik planları oluşturur ve hatta etkiyi doğrulamak için testler/derleme komutları çalıştırır. Ancak, Copilot'ın veya Windsurf'ün Agent'larından farklı olarak, Cursor'ın Agent'ı genellikle ilk bir öneriyi tamamladıktan sonra duraklar, kullanıcı incelemesini ve daha fazla talimatı bekler. Bu, Cursor'ın Agent'ının genellikle kullanıcıdan yeni bir istem almadıkça sürekli ve tekrar tekrar kendini geliştirmediği anlamına gelir. Örneğin, Cursor'dan proje çapında bir yeniden düzenleme yapmasını isterseniz, değiştirilmesi gereken tüm konumları toplar ve kullanıcı incelemesi için her dosya için bir diff oluşturur; bu noktada, kullanıcı hangi değişiklikleri kabul edeceğine ve uygulayacağına karar verir. Bu değişiklikler yeni sorunlar ortaya çıkarırsa, kullanıcı "ortaya çıkan sorunları düzelt" gibi daha fazla istekte bulunmadıkça Cursor keyfi olarak değiştirmeye devam etmez. Bu mekanizma, kritik karar noktalarında insan denetimini sağlayarak yapay zekanın kontrolden çıkmasını önler. Ancak, bu aynı zamanda Cursor'ın Agent'ının uzun zincirli planlama özerkliğinden yoksun olduğu, karmaşık kapalı döngüleri tamamlamak için adım adım insan rehberliği gerektirdiği anlamına gelir. Sürekli özerkliği kısmen iyileştirmek için, Cursor ekibi Agent sistemine bazı yinelemeli özellikler de eklemiştir. Örneğin, kodu derlemeye ve çalıştırmaya çalışacak ve hataları yakalayacak, sözdizimi veya lint hataları gibi bazı basit sorunları otomatik olarak düzeltecektir, ancak genellikle birkaç denemeden sonra durur ve kontrolü kullanıcıya geri verir. Geliştiriciler, Cursor'ın Agent'ının yerel yeniden düzenleme veya sınırlı kapsamlı değişikliklerde çok verimli çalıştığını, ancak yaygın değişiklikler için genellikle kullanıcının görevi adım adım tamamlamak için bölümler halinde istemde bulunmasını gerektirdiğini gözlemlemişlerdir. Genel olarak, Cursor Agent'ı her şeye gücü yeten otomatik bir programlama robotu yerine "akıllı bir yürütme asistanı" olarak konumlandırır; görev planlaması kısa vadeli yürütmeye, zamanında raporlamaya ve bir sonraki adıma insanların karar vermesine yöneliktir.

**Model Çağırma Stratejisi:** Cursor kendi büyük dil modellerini eğitmez; üçüncü taraf API'leri entegre etme stratejisini benimser. Kullanıcılar, OpenAI veya Anthropic gibi satıcılardan API anahtarlarını Cursor içinde yapılandırabilir ve ardından Cursor'ın arka ucu, kullanıcı adına ilgili büyük modeli çağırır. Kullanıcı hangi model sağlayıcısını seçerse seçsin, tüm yapay zeka istekleri Cursor'ın kendi sunucusu üzerinden geçer: yerel uygulama, düzenleyici bağlamını ve kullanıcı sorularını paketler ve buluta gönderir, Cursor'ın sunucusu tam istemi bir araya getirir ve modeli çağırır, ardından sonuçları düzenleyiciye geri döndürür. Bu mimari, Cursor'ın istemleri optimize etmesini ve oturum durumlarını birleşik bir şekilde yönetmesini kolaylaştırır, ancak aynı zamanda çevrimiçi kullanılması gerektiği ve temel yapay zeka işlevlerinin çevrimdışı modda kullanılamadığı anlamına gelir. Geliştirici maliyetleri göz önüne alındığında, Cursor kullanıcıların kendi API kotalarını kullanmasını destekler (böylece model çağırma faturalandırması kullanıcıya gider), ancak buna rağmen, istekler kod gömme alma ve yanıt biçimlendirme gibi işlemler için yine de resmi sunucu üzerinden geçer. Model seçimi açısından, Cursor genellikle birkaç ana akım modeli seçeneği sunar (örn. GPT-4, GPT-3.5, Claude 2, vb.); kullanıcılar birini tercih edebilir, ancak Cursor tarafından desteklenmeyen modellere erişemezler. Buna karşılık, Windsurf gibi sistemler temel motorun değiştirilmesine izin verirken, Cursor daha kapalıdır, model güncellemeleri ve ayarlamaları öncelikli olarak resmi ekip tarafından kontrol edilir. Ek olarak, Cursor'ın Copilot Enterprise gibi yerel dağıtım çözümleri yoktur, ne de açık kaynak modelleri entegre etmez; tamamen bulut hizmeti odaklıdır, bu nedenle en son büyük model sürümlerine hızla ayak uydurabilir, ancak aynı zamanda kullanıcıların bulut işlemine güvenmelerini ve ilgili gizlilik politikalarına uymalarını gerektirir. Cursor'ın "Düşünme modu" sağladığını belirtmekte fayda var; kullanıcı geri bildirimlerine göre, bu modu etkinleştirmek yapay zeka yanıtlarını daha derinlemesine ve titiz hale getirir, bu da muhtemelen daha güçlü bir modele veya özel istem ayarlarına geçiş anlamına gelebilir, ancak belirli uygulama detayları resmi ekip tarafından açıklanmamıştır.

**Durum Yönetimi ve Bağlam Saklama:** Tüm projeyi anlama yeteneğini artırmak için Cursor, kod tabanını yerel olarak veya bulutta ön işler: tüm dosyalar için vektör gömmeleri hesaplar ve anlamsal arama ve alaka eşleştirmeyi desteklemek için bir anlamsal dizin oluşturur. Varsayılan olarak, yeni bir proje açıldığında, Cursor otomatik olarak kod parçacıklarını toplu olarak bulut sunucusuna yükleyerek gömmeler oluşturur ve bunları kaydeder (yalnızca gömme vektörlerini ve dosya hash'lerini depolar, düz metin kodu değil). Bu şekilde, kullanıcılar kod hakkında soru sorduğunda, Cursor gömme alanında ilgili dosyaları veya parçacıkları arayabilir ve içeriklerini modele referans olarak sağlamak üzere çıkarabilir, tüm kod tabanını isteme beslemek zorunda kalmaz. Ancak, sınırlı model bağlam penceresi (binlerce ila on binlerce jeton) nedeniyle, Cursor'ın stratejisi mevcut bağlama odaklanmaktır: yani, modeli esas olarak kullanıcının şu anda düzenlediği dosyaya, seçilen kod segmentine veya kullanıcı tarafından aktif olarak sağlanan parçacıklara odaklanmasını sağlamaktır. Cursor'ın açılmamış dosyaların içeriği hakkında soru sormanıza olanak tanıyan bir "Kod Tabanınızı Biliyor" giriş noktası vardır; bu aslında arka planda anlamsal bir arama yapar ve bulunan ilgili içeriği isteme ekler. Başka bir deyişle, yapay zekanın belirli bir kod parçasını dikkate almasını istiyorsanız, genellikle o dosyayı açmanız veya konuşmaya yapıştırmanız gerekir; aksi takdirde, Cursor varsayılan olarak modele çok fazla "ilgisiz" dosya içeriği beslemez. Bu bağlam yönetimi, yanıtların hassas bir şekilde odaklanmasını sağlar, ancak kullanıcı fark etmedikçe ve yapay zekayı bunları almaya yönlendirmedikçe, projedeki örtük dosya içi ilişkileri kaçırabilir. Uzun vadeli bellek sorununu çözmek için Cursor, Proje Kuralları mekanizması sağlar. Geliştiriciler, önemli proje bilgilerini, kodlama standartlarını veya hatta belirli talimatları kaydetmek için `.cursor/rules/*.mdc` dosyaları oluşturabilir ve Cursor, her oturum başlatıldığında bu kuralları sistem isteminin bir parçası olarak otomatik olarak yükler. Örneğin, "Tüm API fonksiyonları loglama yapmalı" gibi bir kural oluşturabilirsiniz ve Cursor kod üretirken bu kurala uyacaktır; bazı kullanıcılar, kural dosyalarında proje deneyimini sürekli biriktirerek Cursor'ın proje anlayışının ve tutarlılığının önemli ölçüde arttığını bildirmişlerdir. Bu kural dosyaları, Agent'a geliştirici tarafından verilen, insanlar tarafından sürdürülen ve güncellenen uzun vadeli belleğe eşdeğerdir (Cursor'dan "bu konuşmanın sonuçlarını kurallara eklemesi" de istenebilir). Ayrıca, Cursor konuşma geçmişi bağlamının devamını destekler: aynı oturum içinde, kullanıcının sorduğu önceki sorular ve Cursor tarafından sağlanan yanıtlar, çok turlu iletişimde tutarlılığı sağlamak için konuşma zincirinin bir parçası olarak modele iletilir. Ancak, Cursor şu anda oturumlar arası önceki konuşmaları otomatik olarak hatırlamaz (yukarıda bahsedilen kural dosyalarına kaydedilmedikçe); her yeni oturum proje kuralları + mevcut bağlam ile sıfırdan başlar.

**Eklenti Sistemi ve Genişletme Mekanizması:** Cursor'ın Agent'ı Copilot'a benzer işlemleri çağırabilir, ancak Cursor'ın kendisi eksiksiz bir IDE olduğu için, araç entegrasyonu daha yerleşiktir. Örneğin, Cursor `open_file`, `read_file`, `edit_code`, `run_terminal` gibi araçları tanımlar ve sistem isteminde amaçlarını ve kullanımlarını ayrıntılı olarak açıklar. Bu açıklamalar, LLM'nin doğru bağlamda doğru aracı ne zaman kullanacağını bilmesini sağlamak için ekip tarafından tekrar tekrar ince ayar yapılmıştır. Anthropic'in resmi blogu bir zamanlar, bir modele araçları nasıl kullanacağını öğretmek için etkili istemler tasarlamanın başlı başına bir sanat olduğunu belirtmişti ve Cursor'ın bu konuda açıkça çok çaba sarf ettiği görülüyor. Örneğin, Cursor sistem isteminde açıkça belirtir: "Kullanıcıya doğrudan tam kod parçacıkları çıktı vermeyin; bunun yerine `edit_tool` aracılığıyla değişiklikleri gönderin" diyerek yapay zekanın aracı atlayıp doğrudan büyük metin blokları yazdırmasını engeller. Başka bir örnek: "Her aracı çağırmadan önce, kullanıcıya neden böyle yaptığınızı tek bir cümleyle açıklayın," böylece yapay zeka uzun süre bir işlemi "sessizce" gerçekleştirirken kullanıcı yanlışlıkla donduğunu düşünmez. Bu ayrıntılı tasarımlar kullanıcı deneyimini ve güveni artırır. Dahili araçlara ek olarak, Cursor Model Bağlam Protokolü (MCP) aracılığıyla ek "eklentilerin" bağlanmasını da destekler. Mühendislik açısından, Cursor MCP'yi Agent yeteneklerini genişletmek için standart bir arayüz olarak görür: geliştiriciler, veritabanlarına erişim, harici API'leri çağırma veya hatta tarayıcıları kontrol etme gibi çeşitli işlevleri gerçekleştirmek için MCP spesifikasyonuna göre bir hizmet yazabilirler. Örneğin, bazı topluluk kullanıcıları, Cursor'ın Agent'ına etkili bir şekilde "uzun vadeli bellek" ekleyen, daha uzun vadeli proje bilgisini depolamak ve almak için OpenAI'nin vektör veritabanını MCP aracılığıyla entegre ettiklerini paylaşmışlardır. MCP hizmetlerinin genellikle yerel olarak veya özel bir bulutta başlatıldığını belirtmek önemlidir. Cursor, bu hizmetlerin adreslerini ve mevcut talimatlarını yapılandırma dosyaları aracılığıyla bilir ve ardından model, sistem isteminde sağlanan araçlar listesine göre bunları çağırabilir. Özetle, Cursor'ın eklenti mekanizması, Agent'ına belirli bir programlanabilirlik derecesi verir ve kullanıcıların yapay zekanın yeteneklerini genişletmesine olanak tanır.

**Temel Tasarım Takasları ve Yenilikler:** Bir IDE ürünü olarak Cursor, Agent sistem tasarımında GitHub Copilot'a kıyasla farklı takaslar yapmıştır. İlk olarak, bulut tabanlı bir yürütme mimarisi seçmiştir, bu da kullanıcıların güçlü yapay zeka modellerini kullanmak için yerel bilgi işlem gücü hazırlamasına gerek olmadığı ve Cursor'ın arka uç işlevlerini birleşik bir şekilde yükseltebileceği ve optimize edebileceği anlamına gelir. Maliyeti, kullanıcıların bulut hizmetlerine güvenmesi ve ağ gecikmesini kabul etmesidir, ancak Cursor "gizlilik modu" aracılığıyla bazı garantiler sunar (kullanıcı kodunu ve sohbet geçmişini uzun

### Windsurf (Codeium) Ajan Mimarisi

**Mimari Tasarım Felsefesi:** Windsurf, Codeium ekibi tarafından piyasaya sürülen, yapay zeka destekli bir programlama ürünüdür ve sektörün ilk "Ajan Tabanlı IDE"si (Akıllı Ajan Entegre Geliştirme Ortamı) olarak konumlandırılmıştır. Sohbet/Ajan modları arasında geçiş yapmayı gerektiren Copilot'ın aksine, Windsurf'ün yapay zeka asistanı (Cascade adında) baştan sona ajan yeteneklerine sahiptir; soruları yanıtlama ve gerektiğinde çok adımlı görevleri otonom olarak yürütme arasında sorunsuz bir şekilde geçiş yapar. Codeium, felsefesini resmi olarak "Akışlar = Ajanlar + Yardımcı Pilotlar" olarak özetler. Bir Akış, geliştiricilerin ve yapay zekanın senkronize bir işbirliği durumunda olmasını ifade eder: yapay zeka her an bir asistan gibi öneriler sunar ve gerektiğinde proaktif olarak bir dizi işlemi devralıp yürütebilirken, tüm süreç geliştiricinin operasyonlarıyla gerçek zamanlı senkronizasyonda kalır. Bu mimaride belirgin insan-makine rol geçiş noktaları yoktur; yapay zeka, geliştiricinin eylemlerini sürekli "dinler" ve ritme uyum sağlar. Windsurf'te Cascade ile sohbet ettiğinizde, sorularınızı doğrudan yanıtlayabilir veya ifadenizi bir görev olarak yorumlayıp bir dizi işlemi tetikleyebilir. Örneğin, bir kullanıcı Cascade'e bir konuşmada basitçe "Lütfen kullanıcı kimlik doğrulamasını uygulayın ve ilgili kod bölümlerini güncelleyin" derse, Cascade bunu otomatik olarak modüller arası bir gereksinim olarak anlayabilir: kod tabanını arayarak kullanıcı kimlik doğrulamasıyla ilgili dosyaları bulur, bu dosyaları açar ve düzenler (örneğin, kimlik doğrulama işlevleri ekler, yeni yapılandırmalar oluşturur, çağırma mantığını değiştirir), gerekirse proje testlerini çalıştırır ve son olarak tamamlama durumunu kullanıcıya bildirir. Tüm süreç boyunca geliştiricinin mod değiştirmesi veya adım adım istemde bulunması gerekmez. Çok modluluk açısından, mevcut Windsurf/Cascade öncelikle kod metni alanına odaklanmıştır ve henüz görüntü veya ses ayrıştırma desteğinden bahsedilmemiştir. Ancak, Cascade'in "geliştirici niyetini" kavraması sadece saf metin girişinden değil, aynı zamanda IDE ortamındaki çeşitli sinyallerden de gelir (aşağıdaki bağlam bölümüne bakın). Genel olarak, Windsurf'ün mimari felsefesi, yapay zekayı IDE'ye entegre etmektir: pasif bir soru-cevap aracından aktif bir işbirliği ortağına evrilerek geliştirme verimliliğini en üst düzeye çıkarmak.

**Görev Ayrıştırma ve Otonomi:** Cascade, mevcut ürünler arasında en güçlü otonom orkestrasyon yeteneklerinden birine sahiptir. Kullanıcı tarafından verilen üst düzey talimatlar için, önce kapsamlı niyet analizi ve kapsam değerlendirmesi yapar, ardından hedefe ulaşmak için otomatik olarak bir dizi belirli eylemi başlatır. Yeni kimlik doğrulama işlevselliği ekleme örneğinde, Cascade aşağıdaki dahili adımları gerçekleştirebilir: 1) Değiştirilmesi veya oluşturulması gereken modülleri (örneğin, kullanıcı modeli, kimlik doğrulama hizmeti, yapılandırma, kullanıcı arayüzü bileşenleri vb.) bulmak için projeyi tarar; 2) İşlevler ekleme, çağrıları ayarlama ve yapılandırmaları güncelleme dahil olmak üzere ilgili kod değişikliklerini oluşturur; 3) Dosyaları açmak ve değişiklikleri eklemek için Windsurf tarafından sağlanan araçları kullanır; 4) Yeni değişikliklerin doğru çalışıp çalışmadığını kontrol etmek için mevcut test paketlerini çalıştırır veya bir geliştirme sunucusu başlatır. Testler sorunları ortaya çıkarırsa, Cascade durup insan müdahalesi beklemez, bunun yerine hatayı analiz etmeye, hatayı bulmaya, kodu otomatik olarak değiştirmeye ve doğrulama için testleri tekrar çalıştırmaya devam eder. Bu kapalı döngü, Cascade görevin tamamlandığından emin olana veya çözülemeyen bir engelle karşılaşana kadar birkaç tur devam edebilir. Özellikle, Windsurf geliştiriciyi döngüde tutmayı, ancak aşırı yük bindirmemeyi vurgular. Özellikle, Cascade temel değişiklikleri yürüttükten sonra değiştirilen tüm dosyaların farklarını kullanıcıya gösterir ve tek seferlik toplu onay ister. Kullanıcılar her farkı inceleyebilir ve değişiklikleri kabul edip etmeyeceğine veya geri alıp almayacağına karar verebilir. Bu adım, yapay zeka otonom yeniden düzenleme ve kod gönderme arasına etkili bir insan inceleme aşaması ekler, ne yapay zekanın sürekli operasyonlarını aşırı derecede aksatır ne de nihai sonucun insan beklentilerini karşılamasını sağlar. Kullanıcının her adımı yönlendirmesini gerektiren Cursor ile karşılaştırıldığında, Windsurf'ün Cascade'i varsayılan otonomiye eğilimlidir: kullanıcı sadece gereksinimi belirtir ve yapay zeka tüm alt görevleri mümkün olduğunca tamamlar, ardından sonuçları kullanıcıya kabul etmesi için sunar. Bu çalışma modu, yapay zekanın karmaşık işlemleri yönetmedeki avantajını tam olarak kullanırken, "nihai onay" tasarımıyla riski yönetir.

**Model Çağırma Stratejisi:** Windsurf'ün arkasındaki yapay zeka teknolojisi, öncelikle Codeium'un kendi geliştirdiği modelleri ve altyapısından gelir. Codeium, yapay zeka kodlama asistanları alanında deneyim biriktirmiştir (Codeium eklentisi Copilot benzeri tamamlama özellikleri sağlar) ve Cascade tarafından kullanılan modelin Codeium'un programlama için optimize edilmiş büyük dil modeli olduğu tahmin edilmektedir (muhtemelen açık kaynaklı modellere göre ince ayar yapılmış veya birden fazla modeli entegre eden). Açık bir fark, Codeium'un kurumsal kullanıcılar için kendi kendine barındırma seçenekleri sunmasıdır; bu, Windsurf tarafından kullanılan modellerin ve çıkarım hizmetlerinin şirketin kendi sunucularında dağıtılabileceği anlamına gelir. Bu, mimari olarak Codeium'un OpenAI gibi üçüncü taraf API'lerine güvenmediği anlamına gelir; çekirdek modelleri Codeium tarafından sağlanabilir ve müşterinin ortamında çalışabilir. Aslında, Codeium platformu "Motorlar" kavramını destekler; burada kullanıcılar yapay zeka arka uç motorunu seçebilir, örneğin Codeium'un kendi modeli "Sonnet"i (Codeium'un dahili model kod adlarından biri) veya açık kaynaklı bir model alternatifini kullanabilir. Bu tasarım teorik olarak Windsurf'e model esnekliği sağlar: gerekirse, resmi ekip tarafından listelenen birkaç sabit modeli kullanabilen Cursor'ın aksine, başka bir eşdeğer model motoruna geçiş yapabilir. Mevcut varsayılan yapılandırma altında, Windsurf'ün zekasının çoğu Codeium'un çevrimiçi hizmetlerinden gelir ve çıkarım da bulutta gerçekleştirilir. Ancak, tamamen uzak hizmetlere dayanan Cursor'ın aksine, Windsurf bazı yapay zeka işlevlerini yerel olarak optimize etmiştir: örneğin, Sekme tamamlama (Supercomplete) özelliği, resmi bilgilere göre, Codeium'un kendi geliştirdiği küçük modeli tarafından desteklenir ve yerel/yakın sunucularda yüksek hızda çalışır. Bu, günlük kodlama sırasında anlık önerilerin gecikme açısından neredeyse algılanamaz olmasını sağlarken, karmaşık konuşmalar veya büyük ölçekli üretim için güçlü bulut modelleri çağrılır. Veri güvenliğini önemseyen kurumsal müşteriler için Windsurf'ün en büyük satış noktası, "hava boşluklu" dağıtım desteğidir: şirketler, eksiksiz Codeium yapay zeka motorunu güvenlik duvarları içinde kurabilir ve tüm kod ile istem verileri dahili ağ içinde kalır. Bu nedenle, Windsurf, model stratejisinde Cursor'a zıt bir seçim yapmıştır—önde gelen yapay zeka şirketlerinin API'lerine tamamen güvenmek yerine, daha fazla model otonomisi ve dağıtım esnekliği için çabalıyor. Bu seçim daha fazla mühendislik yatırımı (tescilli modelleri eğitme ve sürdürme, ayrıca karmaşık dağıtım desteği) gerektirir, ancak kurumsal pazarda tanınma kazanmıştır. Bu aynı zamanda Codeium'un mühendislik tasarım önceliklerinden biridir.

**Durum Yönetimi ve Bağlam Saklama:** Hedef kullanıcılar büyük kod depolarını yöneten ekipleri içerdiğinden, Windsurf bağlam yönetimi için mühendislik tasarımına büyük yatırım yapmıştır. Çekirdeği, bir dizi kod indeksleme ve alma mekanizmasıdır: bir kullanıcı bir depoyu açtığında, Windsurf tüm kodu otomatik olarak tarar ve yerel olarak anlamsal bir indeks oluşturur (vektör gömme kullanarak). Bu süreç, bir proje tam metin araması oluşturmaya benzer, ancak daha akıllıdır—indeks, yapay zekanın ilgili içeriği herhangi bir dosyadan talep üzerine, o dosyayı açıkça yüklemeden almasına olanak tanır. Bu nedenle, Cascade'in birden fazla dosyayı içeren soruları yanıtlaması gerektiğinde, indeksten ilgili parçacıkları hızla bulabilir ve içeriklerini model bağlamına ekleyebilir. Örneğin, "X işlevi nerede tanımlı?" diye sorarsanız, Cascade o dosyayı hiç açmamış olsa bile indeks aracılığıyla tanımı hemen bulabilir ve bir yanıt sağlayabilir. Bu "küresel bağlam farkındalığı", yapay zekanın büyük projeleri anlama yeteneğini büyük ölçüde artırır çünkü bağlam penceresinin fiziksel sınırlamalarını kırar, esasen yapay zekaya proje hakkında anlık bir sorgu veritabanı sağlar. Buna ek olarak, Windsurf uzun süreli belleğe büyük önem verir ve "Anılar" özelliğini tanıtır. Anılar iki kategoriye ayrılır: biri, geliştiricilerin Cascade'e proaktif olarak bazı kalıcı bilgiler (örneğin, proje mimarisi açıklamaları, kodlama stili kılavuzları vb.) sağlayabileceği kullanıcı tanımlı "notlar" veya "kurallar"dır; bunlar kalıcı olarak depolanır ve ilgili olduğunda modele referans olarak sağlanır. Diğer kategori ise, yapay zeka ile kullanıcı arasındaki geçmiş konuşmaların özetleri, yapay zeka tarafından proje üzerinde alınan önemli kararlar gibi otomatik olarak kaydedilen anılardır; bunlar da depolanır. Birkaç gün sonra Windsurf'ü tekrar açtığınızda, Cascade daha önce tartışılan içeriği ve sonuçları hala "hatırlar", sizin yeniden açıklamanıza gerek kalmaz. Bu, ChatGPT tarzı konuşma belleğini oturumlar arası boyutlara genişletmeye eşdeğerdir. Uygulama açısından, Anılar yerel bir veritabanı veya kullanıcı yapılandırma dosyaları aracılığıyla uygulanmalı, yalnızca kullanıcının veya ekibin erişebilmesi sağlanmalıdır. Küresel indeksleme ve Anılar'a ek olarak, Windsurf'ün benzersiz bir bağlam kaynağı vardır: gerçek zamanlı geliştirici davranışı. Cascade IDE'ye tamamen entegre olduğu için, IDE'deki eylemlerinizi gerçek zamanlı olarak algılayabilir. Örneğin, imlecinizin nerede konumlandığı, hangi kodu düzenlediğiniz veya hangi terminal komutlarını çalıştırdığınız—Cascade bu bilgileri alabilir ve konuşma bağlamına entegre edebilir. Codeium buna "eylemlerinizin gerçek zamanlı farkındalığı" adını verir. Bir senaryoyu düşünün: eğer yeni testleri çalıştırdıysanız, Cascade test çıktısını okuyabilir, bir birim testinin başarısız olduğunu bulabilir ve proaktif olarak bir düzeltme önerebilir—siz başarısızlık günlüğünü görmesi için açıkça kopyalamış olsanız bile. Veya bir ön uç kod dosyasını açarsanız, Cascade o dosyayı hemen çeker ve arka planda analiz eder, böylece ilgili bir soru sorduğunuzda gecikme olmaz. İnsan operasyonlarını gerçek zamanlı takip etme, insan-makine işbirliğini daha doğal ve akıcı hale getirir, sanki Cascade ekranınızı sürekli izleyen bir asistandır. Özetle, Windsurf, yerel indeksleme + oturumlar arası bellek + gerçek zamanlı çevresel farkındalığın birleşimiyle şu anda

### System Comparison Summary

Below is a table summarizing the similarities and differences in the Agent architectures of GitHub Copilot, Cursor, and Windsurf:

| Feature Dimension | GitHub Copilot | Cursor | Windsurf (Codeium) |
|---|---|---|---|
| **Architectural Positioning** | Started as a chatbot for programming assistance, expanded into "Agent mode" (codename Project Padawan); the Agent can be embedded into the GitHub platform, integrated with Issues/PR workflows. Multi-turn conversation single Agent, no explicit multi-Agent architecture. Supports multi-modal input (visuals). | AI-first native editor (VS Code derivative), includes Chat mode and Agent mode interactions. While the default assistant mode focuses on Q&A and completion, Agent mode requires explicit activation for the AI to autonomously execute tasks. Single Agent architecture, no multi-modal processing. | Designed as an "Agent IDE" from the outset: AI assistant Cascade is always online, capable of both chat and autonomous multi-step operations, no mode switching required. Single Agent execution, enables synchronized human-AI collaboration via Flows, currently focused on code text. |
| **Task Planning and Execution** | Supports automatic task decomposition and iterative execution. The Agent breaks down user requests into sub-tasks and completes them iteratively until the goal is reached or explicitly stopped. Has self-healing capabilities (can identify and fix compilation/test errors). After each task completion, it presents results as a PR and awaits human review; review feedback triggers the next iteration. | Can manage cross-file changes but tends towards single-turn execution: the Agent receives instructions and presents all proposed changes at once, listing diffs for user approval. Generally does not autonomously iterate over multiple turns (unless the user explicitly requests it again), and errors are usually left for the user to decide whether the AI should fix them. By default, it performs only a limited number of automatic correction cycles, preventing indefinite stalling. | Deep autonomy: Cascade can decompose high-level requirements into a series of actions and continuously execute them until the task is complete. Excels in large refactorings and cross-module tasks, automatically chaining calls to editing, file creation, command execution, test verification, etc., until the code passes self-inspection. If new issues are found during the process, it continues to iterate and fix them, requiring almost no human intervention except for the final result (though critical changes will require human final approval). |
| **Model Strategy** | Cloud multi-model fusion: Supports OpenAI GPT-4, GPT-3.5 series (internal codenames o1, o3-mini, etc.), Anthropic Claude 3.5, Google Gemini 2.0, etc., and users can switch their preferred models in the interface. Enhances efficiency through a dual-model architecture (large model generates solutions, small model rapidly applies changes). Models are uniformly hosted and invoked by GitHub; Copilot Enterprise user requests pass through dedicated instances. Does not support private deployment. | Relies entirely on third-party large model APIs: all requests are transmitted via Cursor's cloud and invoke OpenAI/Anthropic models. Users can use their own API Keys (billing is self-managed) but the call still occurs on official servers. No offline or local model options. Model types depend on the range supported by Cursor; users cannot freely integrate new models. Cursor does not directly train models but adapts external models by optimizing prompts. | Primarily self-developed models, flexible backend: by default uses Codeium's proprietary code models and allows enterprise users to choose self-hosted deployment. The architecture supports switching different model engines (Codeium "Sonnet" model or open source, etc.) and may expand third-party interfaces in the future. Some lightweight functions use small models for local/edge computing to reduce latency. Emphasizes user control over the AI environment (model update speed, version stability are user-controlled). |
| **Context and Memory** | Uses a RAG strategy to obtain code context: retrieves relevant code snippets via GitHub Code Search and injects them into prompts. Prompts include a project structure summary instead of full text to save tokens. Supports including Issue descriptions, relevant PR discussions in context to understand task intent and project standards. Conversation history is stored within a single session; no automatic cross-session memory (requires relying on Issues/PRs or READMEs to carry information across sessions). | Initially creates a vector index for the project to support semantic search. Model prompts focus on the code context currently provided by the user (open files or snippets); when other parts are needed, they are retrieved and appended via semantic relevance. Provides a `.cursor/rules` file mechanism allowing developers to define persistent knowledge and standards for the project; the Agent reads these rules in every conversation, which is equivalent to human-provided long-term memory. By default, no automatic cross-session memory (requires the user to manually save to rule files). | Full project semantic indexing: locally pre-scans the entire codebase to create an index; Cascade can retrieve any file content as context at any time. Includes a Memories system that automatically and persistently saves important conversation content and user-specified notes/rules, thus providing cross-session memory. This allows Cascade to "remember" project rules and previous discussions even after restarting. It also integrates the IDE environment state as a context source: real-time perception of the user's open files, cursor position, terminal output, etc., uses this implicit information to understand user intent. Overall, Cascade has a broader and more dynamic view of context. |
| **Tools and Extensions** | Deep integration with GitHub workflow: The Agent obtains an isolated development environment in the cloud via GitHub Actions, can run unit tests, execute projects, etc. Internal tools include reading files, searching repositories, applying code changes, terminal commands, etc., and the LLM can invoke them as needed. Introduces the MCP (Model Context Protocol) standard, supporting connection to external data sources and services; official MCP plugins can access GitHub data, and a global open interface is available for third-party extensions. Has computer vision capabilities, can parse screenshots attached to Issues as the basis for problems. | Provides rich IDE manipulation tools, precisely guided by system prompts on how to use them (e.g., requiring the AI to read file content before modifying, avoiding blind writing not based on context). Provides plugin capability via the MCP interface, allowing connection to custom tools/data sources, extending Agent capabilities. For example, developers can add a database query plugin to allow the Cursor Agent to use the latest database schema information in the code. The Cursor Agent strictly adheres to predefined rules for tool usage (e.g., explaining actions before invoking), enhancing interaction predictability. | Most comprehensive tool integration: Cascade has extensive operational control over the editor and system, from the file system to the terminal. Supports automatic command execution (e.g., compile, test) and using results for subsequent actions. Supports MCP plugins from Wave 3 onwards, allowing external services to become Cascade's tools via JSON configuration (e.g., map APIs, database interfaces). Cascade also monitors IDE state (clipboard content, current selection, etc.) for smarter responses. For security, Windsurf requires user approval for critical changes and pre-configuration for external service calls to prevent misuse. Overall, Cascade is almost equivalent to an AI development partner with IDE plugin and Shell script capabilities. |
| **Engineering Trade-offs and Innovation** | Platform integration: Fully leverages existing GitHub infrastructure (Actions, PR mechanisms, etc.) to host the Agent. Security first: built-in policies to prevent unreviewed code from directly affecting the main branch and production environment. Proposed the MCP open standard, pioneering the industrial exploration of a universal solution for LLMs to invoke external tools. Transparency: allows users to view Agent execution logs to understand the decision-making process, increasing trust. Innovation lies in deeply embedding AI into various stages of the development workflow to achieve closed-loop human-AI collaborative development. | Cloud service: the chosen cloud architecture provides large model performance and unified management, but sacrifices offline capability. Fine-tuned prompts: transforming LLMs into professional code assistants relies on a vast collection of system prompts and tool instructions; Cursor's investment in this area has made its output quality highly regarded. Human oversight: prefers an extra human approval step rather than giving AI full freedom to modify code—this conservative strategy reduces the risk of errors and increases user trust. Customizability: through rule files and plugins, Cursor allows advanced users to... |
```
